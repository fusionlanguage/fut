// Sema.ci - semantic analysis of Ci
//
// Copyright (C) 2011-2023  Piotr Fusik
//
// This file is part of CiTo, see https://github.com/pfusik/cito
//
// CiTo is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CiTo is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CiTo.  If not, see http://www.gnu.org/licenses/

public class CiSema : CiVisitor
{
	protected CiProgram! Program;
	CiMethodBase!? CurrentMethod;
	CiScope!? CurrentScope;
	HashSet<CiMethod>() CurrentPureMethods;
	Dictionary<CiVar, CiExpr#>() CurrentPureArguments;
	CiType# Poison = new CiType { Name = "poison" };

	protected override CiContainerType GetCurrentContainer() => this.CurrentScope.GetContainer();

	CiType# PoisonError!(CiStatement statement, string message)
	{
		ReportError(statement, message);
		return this.Poison;
	}

	void ResolveBase!(CiClass! klass)
	{
		if (klass.HasBaseClass()) {
			this.CurrentScope = klass;
			if (this.Program.TryLookup(klass.BaseClassName, true) is CiClass! baseClass) {
				if (klass.IsPublic && !baseClass.IsPublic)
					ReportError(klass, "Public class cannot derive from an internal class");
				baseClass.HasSubclasses = true;
				klass.Parent = baseClass;
			}
			else
				ReportError(klass, $"Base class {klass.BaseClassName} not found");
		}
		this.Program.Classes.Add(klass);
	}

	void CheckBaseCycle!(CiClass! klass)
	{
		// Floyd's tortoise and hare cycle-finding algorithm
		CiSymbol? hare = klass;
		CiSymbol tortoise = klass;
		do {
			hare = hare.Parent;
			if (hare == null)
				return;
			hare = hare.Parent;
			if (hare == null)
				return;
			tortoise = tortoise.Parent;
		} while (tortoise != hare);
		this.CurrentScope = klass;
		ReportError(klass, $"Circular inheritance for class {klass.Name}");
	}

	static void TakePtr(CiExpr expr)
	{
		if (expr.Type is CiArrayStorageType! arrayStg)
			arrayStg.PtrTaken = true;
	}

	bool Coerce!(CiExpr expr, CiType type)
	{
		if (expr == this.Poison)
			return false;
		if (!type.IsAssignableFrom(expr.Type)) {
			ReportError(expr, $"Cannot coerce {expr.Type} to {type}");
			return false;
		}
		if (expr is CiPrefixExpr prefix && prefix.Op == CiToken.New && !(type is CiDynamicPtrType)) {
			assert expr.Type is CiDynamicPtrType newType;
			string kind = newType.Class.Id == CiId.ArrayPtrClass ? "array" : "object";
			ReportError(expr, $"Dynamically allocated {kind} must be assigned to a {expr.Type} reference");
			return false;
		}
		TakePtr(expr);
		return true;
	}

	CiExpr# VisitInterpolatedString!(CiInterpolatedString# expr)
	{
		int partsCount = 0;
		string() s = "";
		for (int partsIndex = 0; partsIndex < expr.Parts.Count; partsIndex++) {
			CiInterpolatedPart part = expr.Parts[partsIndex];
			s += part.Prefix;
			CiExpr# arg = Resolve(part.Argument);
			Coerce(arg, this.Program.System.PrintableType);
			switch (arg.Type) {
			case CiIntegerType _:
				switch (part.Format) {
				case ' ':
					if (arg is CiLiteralLong literalLong && part.WidthExpr == null) {
						s += $"{literalLong.Value}";
						continue;
					}
					break;
				case 'D':
				case 'd':
				case 'X':
				case 'x':
					break;
				default:
					ReportError(arg, "Invalid format string");
					break;
				}
				break;
			case CiFloatingType _:
				switch (part.Format) {
				case ' ':
				case 'F':
				case 'f':
				case 'E':
				case 'e':
					break;
				default:
					ReportError(arg, "Invalid format string");
					break;
				}
				break;
			default:
				if (part.Format != ' ')
					ReportError(arg, "Invalid format string");
				else if (arg is CiLiteralString literalString && part.WidthExpr == null) {
					s += literalString.Value;
					continue;
				}
				break;
			}
			CiInterpolatedPart! targetPart = expr.Parts[partsCount++];
			targetPart.Prefix = s;
			targetPart.Argument = arg;
			targetPart.WidthExpr = part.WidthExpr;
			targetPart.Width = part.WidthExpr != null ? FoldConstInt(part.WidthExpr) : 0;
			targetPart.Format = part.Format;
			targetPart.Precision = part.Precision;
			s = "";
		}
		s += expr.Suffix;
		if (partsCount == 0)
			return this.Program.System.NewLiteralString(s, expr.Line);
		expr.Type = this.Program.System.StringStorageType;
		expr.Parts.RemoveRange(partsCount, expr.Parts.Count - partsCount);
		expr.Suffix = s;
		return expr;
	}

	CiExpr# Lookup!(CiSymbolReference# expr, CiScope scope)
	{
		if (expr.Symbol == null) {
			expr.Symbol = scope.TryLookup(expr.Name, expr.Left == null);
			if (expr.Symbol == null)
				return PoisonError(expr, $"{expr.Name} not found");
			expr.Type = expr.Symbol.Type;
		}
		if (!(scope is CiEnum) && expr.Symbol is CiConst! konst) {
			ResolveConst(konst);
			if (konst.Value is CiLiteral || konst.Value is CiSymbolReference)
				return konst.Value;
		}
		return expr;
	}

	CiExpr# VisitSymbolReference!(CiSymbolReference# expr)
	{
		if (expr.Left == null) {
			CiExpr# resolved = Lookup(expr, this.CurrentScope);
			if (expr.Symbol is CiMember nearMember) {
				if (nearMember.Visibility == CiVisibility.Private
				 && nearMember.Parent is CiClass memberClass // not local const
				 && memberClass != GetCurrentContainer())
					ReportError(expr, $"Cannot access private member {expr.Name}");
				if (!nearMember.IsStatic()
				 && (this.CurrentMethod == null || this.CurrentMethod.IsStatic()))
					ReportError(expr, $"Cannot use instance member {expr.Name} from static context");
			}
			if (resolved is CiSymbolReference symbol
			 && symbol.Symbol is CiVar v) {
				if (v.Parent is CiFor! loop)
					loop.IsIteratorUsed = true;
				else if (this.CurrentPureArguments.ContainsKey(v)) // TryGetValue
					return this.CurrentPureArguments[v];
			}
			return resolved;
		}

		CiExpr# left = Resolve(expr.Left);
		if (left == this.Poison)
			return left;
		CiScope scope;
		bool isBase = left is CiSymbolReference baseSymbol && baseSymbol.Symbol.Id == CiId.BasePtr;
		if (isBase) {
			if (this.CurrentMethod == null || !(this.CurrentMethod.Parent.Parent is CiClass baseClass))
				return PoisonError(expr, "No base class");
			scope = baseClass;
			// TODO: static?
		}
		else if (left is CiSymbolReference leftSymbol && leftSymbol.Symbol is CiScope obj)
			scope = obj;
		else {
			scope = left.Type;
			if (scope is CiClassType klass)
				scope = klass.Class;
		}
		CiExpr# result = Lookup(expr, scope);
		if (result != expr)
			return result;
		if (expr.Symbol is CiMember member) {
			switch (member.Visibility) {
			case CiVisibility.Private:
				if (member.Parent != this.CurrentMethod.Parent
				 || this.CurrentMethod.Parent != scope) // enforced by Java, but not C++/C#/TS
					ReportError(expr, $"Cannot access private member {expr.Name}");
				break;
			case CiVisibility.Protected:
				if (isBase)
					break;
				assert this.CurrentMethod.Parent is CiClass currentClass;
				assert scope is CiClass scopeClass;
				if (!currentClass.IsSameOrBaseOf(scopeClass)) // enforced by C++/C#/TS but not Java 
					ReportError(expr, $"Cannot access protected member {expr.Name}");
				break;
			case CiVisibility.NumericElementType:
				if (left.Type is CiClassType klass && !(klass.GetElementType() is CiNumericType))
					ReportError(expr, "Method restricted to collections of numbers");
				break;
			case CiVisibility.FinalValueType: // DictionaryAdd
				if (!left.Type.AsClassType().GetValueType().IsFinal())
					ReportError(expr, "Method restricted to dictionaries with storage values");
				break;
			default:
				switch (expr.Symbol.Id) {
				case CiId.ArrayLength:
					assert left.Type is CiArrayStorageType arrayStorage;
					return ToLiteralLong(expr, arrayStorage.Length);
				case CiId.StringLength:
					if (left is CiLiteralString leftLiteral) {
						int length = leftLiteral.GetAsciiLength();
						if (length >= 0)
							return ToLiteralLong(expr, length);
					}
					break;
				default:
					break;
				}
				break;
			}
			if (!(member is CiMethodGroup)) {
				if (left is CiSymbolReference leftContainer && leftContainer.Symbol is CiContainerType) {
					if (!member.IsStatic())
						ReportError(expr, $"Cannot use instance member {expr.Name} without an object");
				}
				else if (member.IsStatic())
					ReportError(expr, $"{expr.Name} is static");
			}
		}
		return new CiSymbolReference { Line = expr.Line, Left = left, Name = expr.Name, Symbol = expr.Symbol, Type = expr.Type };
	}

	static CiRangeType# Union(CiRangeType# left, CiRangeType#? right)
	{
		if (right == null)
			return left;
		if (right.Min < left.Min) {
			if (right.Max >= left.Max)
				return right;
			return CiRangeType.New(right.Min, left.Max);
		}
		if (right.Max > left.Max)
			return CiRangeType.New(left.Min, right.Max);
		return left;
	}

	CiType# GetIntegerType!(CiExpr left, CiExpr right)
	{
		CiType# type = this.Program.System.PromoteIntegerTypes(left.Type, right.Type);
		Coerce(left, type);
		Coerce(right, type);
		return type;
	}

	CiIntegerType# GetShiftType!(CiExpr left, CiExpr right)
	{
		CiIntegerType# intType = this.Program.System.IntType;
		Coerce(right, intType);
		if (left.Type.Id == CiId.LongType) {
			assert left.Type is CiIntegerType# longType;
			return longType;
		}
		Coerce(left, intType);
		return intType;
	}

	CiType# GetNumericType!(CiExpr left, CiExpr right)
	{
		CiType# type = this.Program.System.PromoteNumericTypes(left.Type, right.Type);
		Coerce(left, type);
		Coerce(right, type);
		return type;
	}

	static int SaturatedNeg(int a)
	{
		if (a == int.MinValue)
			return int.MaxValue;
		return -a;
	}

	static int SaturatedAdd(int a, int b)
	{
		int c = a + b;
		if (c >= 0) {
			if (a < 0 && b < 0)
				return int.MinValue;
		}
		else if (a > 0 && b > 0)
			return int.MaxValue;
		return c;
	}

	static int SaturatedSub(int a, int b)
	{
		if (b == int.MinValue)
			return a < 0 ? a ^ b : int.MaxValue;
		return SaturatedAdd(a, -b);
	}

	static int SaturatedMul(int a, int b)
	{
		if (a == 0 || b == 0)
			return 0;
		if (a == int.MinValue)
			return b >> 31 ^ a;
		if (b == int.MinValue)
			return a >> 31 ^ b;
		if (int.MaxValue / Math.Abs(a) < Math.Abs(b))
			return (a ^ b) >> 31 ^ int.MaxValue;
		return a * b;
	}

	static int SaturatedDiv(int a, int b)
	{
		if (a == int.MinValue && b == -1)
			return int.MaxValue;
		return a / b;
	}

	static int SaturatedShiftRight(int a, int b) => a >> (b >= 31 || b < 0 ? 31 : b);

	static CiRangeType# BitwiseUnsignedOp(CiRangeType left, CiToken op, CiRangeType right)
	{
		int leftVariableBits = left.GetVariableBits();
		int rightVariableBits = right.GetVariableBits();
		int min;
		int max;
		switch (op) {
		case CiToken.And:
			min = left.Min & right.Min & ~CiRangeType.GetMask(~left.Min & ~right.Min & (leftVariableBits | rightVariableBits));
			// Calculate upper bound with variable bits set
			max = (left.Max | leftVariableBits) & (right.Max | rightVariableBits);
			// The upper bound will never exceed the input
			if (max > left.Max)
				max = left.Max;
			if (max > right.Max)
				max = right.Max;
			break;
		case CiToken.Or:
			min = (left.Min & ~leftVariableBits) | (right.Min & ~rightVariableBits);
			max = left.Max | right.Max | CiRangeType.GetMask(left.Max & right.Max & CiRangeType.GetMask(leftVariableBits | rightVariableBits));
			// The lower bound will never be less than the input
			if (min < left.Min)
				min = left.Min;
			if (min < right.Min)
				min = right.Min;
			break;
		case CiToken.Xor:
			int variableBits = leftVariableBits | rightVariableBits;
			min = (left.Min ^ right.Min) & ~variableBits;
			max = (left.Max ^ right.Max) | variableBits;
			break;
		default:
			assert false;
		}
		if (min > max)
			return CiRangeType.New(max, min); // FIXME: this is wrong! e.g. min=0 max=0x8000000_00000000 then 5 should be in range
		return CiRangeType.New(min, max);
	}

	bool IsEnumOp!(CiExpr left, CiExpr right)
	{
		if (left.Type is CiEnum) {
			if (left.Type.Id != CiId.BoolType && !(left.Type is CiEnumFlags))
				ReportError(left, $"Define flags enumeration as: enum* {left.Type}");
			Coerce(right, left.Type);
			return true;
		}
		return false;
	}

	CiType# BitwiseOp!(CiExpr left, CiToken op, CiExpr right)
	{
		if (left.Type is CiRangeType# leftRange && right.Type is CiRangeType# rightRange) {
			CiRangeType#? range = null;
			CiRangeType#? rightNegative;
			CiRangeType#? rightPositive;
			if (rightRange.Min >= 0) {
				rightNegative = null;
				rightPositive = rightRange;
			}
			else if (rightRange.Max < 0) {
				rightNegative = rightRange;
				rightPositive = null;
			}
			else {
				rightNegative = CiRangeType.New(rightRange.Min, -1);
				rightPositive = CiRangeType.New(0, rightRange.Max);
			}
			if (leftRange.Min < 0) {
				CiRangeType leftNegative = leftRange.Max < 0 ? leftRange : CiRangeType.New(leftRange.Min, -1);
				if (rightNegative != null)
					range = BitwiseUnsignedOp(leftNegative, op, rightNegative);
				if (rightPositive != null)
					range = Union(BitwiseUnsignedOp(leftNegative, op, rightPositive), range);
			}
			if (leftRange.Max >= 0) {
				CiRangeType leftPositive = leftRange.Min >= 0 ? leftRange : CiRangeType.New(0, leftRange.Max);
				if (rightNegative != null)
					range = Union(BitwiseUnsignedOp(leftPositive, op, rightNegative), range);
				if (rightPositive != null)
					range = Union(BitwiseUnsignedOp(leftPositive, op, rightPositive), range);
			}
			return range;
		}
		if (IsEnumOp(left, right))
			return left.Type;
		return GetIntegerType(left, right);
	}

	static CiRangeType# NewRangeType(int a, int b, int c, int d)
	{
		if (a > b) {
			int t = a;
			a = b;
			b = t;
		}
		if (c > d) {
			int t = c;
			c = d;
			d = t;
		}
		return CiRangeType.New(a <= c ? a : c, b >= d ? b : d);
	}

	CiLiteral# ToLiteralBool(CiExpr expr, bool value)
	{
		CiLiteral# result = value ? new CiLiteralTrue() : new CiLiteralFalse();
		result.Line = expr.Line;
		result.Type = this.Program.System.BoolType;
		return result;
	}

	CiLiteralLong# ToLiteralLong(CiExpr expr, long value) => this.Program.System.NewLiteralLong(value, expr.Line);

	CiLiteralDouble# ToLiteralDouble(CiExpr expr, double value) => new CiLiteralDouble { Line = expr.Line, Type = this.Program.System.DoubleType, Value = value };

	void CheckLValue!(CiExpr expr)
	{
		switch (expr) {
		case CiSymbolReference symbol:
			switch (symbol.Symbol) {
			case CiVar! def:
				def.IsAssigned = true;
				switch (symbol.Symbol.Parent) {
				case CiFor! forLoop:
					forLoop.IsRange = false;
					break;
				case CiForeach _:
					ReportError(expr, "Cannot assign a foreach iteration variable");
					break;
				default:
					break;
				}
				for (CiScope! scope = this.CurrentScope; !(scope is CiClass); scope = scope.Parent) {
					if (scope is CiFor! forLoop
					 && forLoop.IsRange
					 && forLoop.Cond is CiBinaryExpr binaryCond
					 && binaryCond.Right.IsReferenceTo(symbol.Symbol))
						forLoop.IsRange = false;
				}
				break;
			case CiField _:
				if (symbol.Left == null) {
					if (!this.CurrentMethod.IsMutator)
						ReportError(expr, "Cannot modify field in a non-mutating method");
				}
				else {
					switch (symbol.Left.Type) {
					case CiStorageType _:
						// TODO
						break;
					case CiReadWriteClassType _:
						break;
					case CiClassType _:
						ReportError(expr, "Cannot modify field through a read-only reference");
						break;
					default:
						assert false;
					}
				}
				break;
			default:
				ReportError(expr, "Cannot modify this");
				break;
			}
			break;
		case CiBinaryExpr indexing when indexing.Op == CiToken.LeftBracket:
			switch (indexing.Left.Type) {
			case CiStorageType _:
				// TODO
				break;
			case CiReadWriteClassType _:
				break;
			case CiClassType _:
				ReportError(expr, "Cannot modify array through a read-only reference");
				break;
			default:
				assert false;
			}
			break;
		default:
			ReportError(expr, "Cannot modify this");
			break;
		}
	}

	CiInterpolatedString# Concatenate(CiInterpolatedString left, CiInterpolatedString right)
	{
		CiInterpolatedString# result = new CiInterpolatedString { Line = left.Line, Type = this.Program.System.StringStorageType };
		result.Parts.AddRange(left.Parts);
		if (right.Parts.Count == 0)
			result.Suffix = left.Suffix + right.Suffix;
		else {
			result.Parts.AddRange(right.Parts);
			CiInterpolatedPart! middle = result.Parts[left.Parts.Count];
			middle.Prefix = left.Suffix + middle.Prefix;
			result.Suffix = right.Suffix;
		}
		return result;
	}

	CiInterpolatedString# ToInterpolatedString(CiExpr# expr)
	{
		if (expr is CiInterpolatedString# interpolated)
			return interpolated;
		CiInterpolatedString# result = new CiInterpolatedString { Line = expr.Line, Type = this.Program.System.StringStorageType };
		if (expr is CiLiteral literal)
			result.Suffix = literal.GetLiteralString();
		else {
			result.AddPart("", expr);
			result.Suffix = "";
		}
		return result;
	}

	void CheckComparison!(CiExpr left, CiExpr right)
	{
		if (left.Type is CiEnum)
			Coerce(right, left.Type);
		else {
			CiType doubleType = this.Program.System.DoubleType;
			Coerce(left, doubleType);
			Coerce(right, doubleType);
		}
	}

	void OpenScope!(CiScope! scope)
	{
		scope.Parent = this.CurrentScope;
		this.CurrentScope = scope;
	}

	void CloseScope!()
	{
		this.CurrentScope = this.CurrentScope.Parent;
	}

	CiExpr# ResolveNew!(CiPrefixExpr# expr)
	{
		if (expr.Type != null)
			return expr;
		if (expr.Inner is CiBinaryExpr binaryNew && binaryNew.Op == CiToken.LeftBrace) {
			if (!(ToType(binaryNew.Left, true) is CiClassType klass) || klass is CiReadWriteClassType)
				return PoisonError(expr, "Invalid argument to new");
			assert binaryNew.Right is CiAggregateInitializer# init;
			ResolveObjectLiteral(klass, init);
			expr.Type = new CiDynamicPtrType { Line = expr.Line, Class = klass.Class };
			expr.Inner = init;
			return expr;
		}
		switch (ToType(expr.Inner, true)) {
		case CiArrayStorageType array:
			expr.Type = new CiDynamicPtrType { Line = expr.Line, Class = this.Program.System.ArrayPtrClass, TypeArg0 = array.GetElementType() };
			expr.Inner = array.LengthExpr;
			return expr;
		case CiStorageType klass:
			expr.Type = new CiDynamicPtrType { Line = expr.Line, Class = klass.Class };
			expr.Inner = null;
			return expr;
		default:
			return PoisonError(expr, "Invalid argument to new");
		}
	}

	protected virtual int GetResourceLength!(string name, CiPrefixExpr expr) => 0;

	CiExpr# VisitPrefixExpr!(CiPrefixExpr# expr)
	{
		CiExpr# inner;
		CiType# type;
		switch (expr.Op) {
		case CiToken.Increment:
		case CiToken.Decrement:
			inner = Resolve(expr.Inner);
			CheckLValue(inner);
			Coerce(inner, this.Program.System.DoubleType);
			if (inner.Type is CiRangeType xcrementRange) {
				int delta = expr.Op == CiToken.Increment ? 1 : -1;
				type = CiRangeType.New(xcrementRange.Min + delta, xcrementRange.Max + delta);
			}
			else
				type = inner.Type;
			expr.Inner = inner;
			expr.Type = type;
			return expr;
		case CiToken.Minus:
			inner = Resolve(expr.Inner);
			Coerce(inner, this.Program.System.DoubleType);
			if (inner.Type is CiRangeType negRange)
				type = CiRangeType.New(SaturatedNeg(negRange.Max), SaturatedNeg(negRange.Min));
			else if (inner is CiLiteralDouble d)
				return ToLiteralDouble(expr, -d.Value);
			else if (inner is CiLiteralLong l)
				return ToLiteralLong(expr, -l.Value);
			else
				type = inner.Type;
			break;
		case CiToken.Tilde:
			inner = Resolve(expr.Inner);
			if (inner.Type is CiEnumFlags)
				type = inner.Type;
			else {
				Coerce(inner, this.Program.System.IntType);
				if (inner.Type is CiRangeType notRange)
					type = CiRangeType.New(~notRange.Max, ~notRange.Min);
				else
					type = inner.Type;
			}
			break;
		case CiToken.ExclamationMark:
			inner = ResolveBool(expr.Inner);
			return new CiPrefixExpr { Line = expr.Line, Op = CiToken.ExclamationMark, Inner = inner, Type = this.Program.System.BoolType };
		case CiToken.New:
			return ResolveNew(expr);
		case CiToken.Resource:
			if (!(FoldConst(expr.Inner) is CiLiteralString# resourceName))
				return PoisonError(expr, "Resource name must be string");
			inner = resourceName;
			type = new CiArrayStorageType { Class = this.Program.System.ArrayStorageClass, TypeArg0 = this.Program.System.ByteType, Length = GetResourceLength(resourceName.Value, expr) };
			break;
		default:
			assert false;
		}
		if (type is CiRangeType range && range.Min == range.Max)
			return ToLiteralLong(expr, range.Min);
		return new CiPrefixExpr { Line = expr.Line, Op = expr.Op, Inner = inner, Type = type };
	}

	CiExpr# VisitPostfixExpr!(CiPostfixExpr# expr)
	{
		expr.Inner = Resolve(expr.Inner);
		switch (expr.Op) {
		case CiToken.Increment:
		case CiToken.Decrement:
			CheckLValue(expr.Inner);
			Coerce(expr.Inner, this.Program.System.DoubleType);
			expr.Type = expr.Inner.Type;
			return expr;
		default:
			return PoisonError(expr, $"Unexpected {CiLexer.TokenToString(expr.Op)}");
		}
	}

	CiExpr# ResolveEquality!(CiBinaryExpr expr, CiExpr# left, CiExpr# right)
	{
		if (left.Type is CiRangeType leftRange && right.Type is CiRangeType rightRange) {
			if (leftRange.Min == leftRange.Max && leftRange.Min == rightRange.Min && leftRange.Min == rightRange.Max)
				return ToLiteralBool(expr, expr.Op == CiToken.Equal);
			if (leftRange.Max < rightRange.Min || leftRange.Min > rightRange.Max)
				return ToLiteralBool(expr, expr.Op == CiToken.NotEqual);
		}
		else if (left.Type == right.Type) {
			switch (left) {
			case CiLiteralLong leftLong when right is CiLiteralLong rightLong:
				return ToLiteralBool(expr, (expr.Op == CiToken.NotEqual) ^ (leftLong.Value == rightLong.Value));
			case CiLiteralDouble leftDouble when right is CiLiteralDouble rightDouble:
				return ToLiteralBool(expr, (expr.Op == CiToken.NotEqual) ^ (leftDouble.Value == rightDouble.Value));
			case CiLiteralString leftString when right is CiLiteralString rightString:
				return ToLiteralBool(expr, (expr.Op == CiToken.NotEqual) ^ (leftString.Value == rightString.Value));
			case CiLiteralNull _:
				return ToLiteralBool(expr, expr.Op == CiToken.Equal);
			case CiLiteralFalse _:
				return ToLiteralBool(expr, (expr.Op == CiToken.NotEqual) ^ (right is CiLiteralFalse));
			case CiLiteralTrue _:
				return ToLiteralBool(expr, (expr.Op == CiToken.NotEqual) ^ (right is CiLiteralTrue));
			default:
				break;
			}
			if (left.IsConstEnum() && right.IsConstEnum())
				return ToLiteralBool(expr, (expr.Op == CiToken.NotEqual) ^ (left.IntValue() == right.IntValue()));
		}
		if (!left.Type.IsAssignableFrom(right.Type) && !right.Type.IsAssignableFrom(left.Type))
			return PoisonError(expr, $"Cannot compare {left.Type} with {right.Type}");
		TakePtr(left);
		TakePtr(right);
		return new CiBinaryExpr { Line = expr.Line, Left = left, Op = expr.Op, Right = right, Type = this.Program.System.BoolType };
	}

	CiExpr# ResolveIs!(CiBinaryExpr# expr, CiExpr# left, CiExpr right)
	{
		if (!(left.Type is CiClassType leftPtr) || left.Type is CiStorageType)
			return PoisonError(expr, "Left hand side of the 'is' operator must be an object reference");
		CiClass klass;
		switch (right) {
		case CiSymbolReference symbol:
			if (symbol.Symbol is CiClass klass2)
				klass = klass2;
			else
				return PoisonError(expr, "Right hand side of the 'is' operator must be a class name");
			break;
		case CiVar def:
			if (!(def.Type is CiClassType rightPtr))
				return PoisonError(expr, "Right hand side of the 'is' operator must be an object reference definition");
			if (rightPtr is CiReadWriteClassType
			 && !(leftPtr is CiDynamicPtrType)
			 && (rightPtr is CiDynamicPtrType || !(leftPtr is CiReadWriteClassType)))
				return PoisonError(expr, $"{leftPtr} cannot be casted to {rightPtr}");
			// TODO: outside assert NotSupported(expr, "'is' operator", "c", "cpp", "js", "py", "swift", "ts", "cl");
			klass = rightPtr.Class;
			break;
		default:
			return PoisonError(expr, "Right hand side of the 'is' operator must be a class name");
		}
		if (klass.IsSameOrBaseOf(leftPtr.Class))
			return PoisonError(expr, $"{leftPtr} is {klass.Name}, the 'is' operator would always return 'true'");
		if (!leftPtr.Class.IsSameOrBaseOf(klass))
			return PoisonError(expr, $"{leftPtr} is not base class of {klass.Name}, the 'is' operator would always return 'false'");
		expr.Left = left;
		expr.Type = this.Program.System.BoolType;
		return expr;
	}

	CiExpr# VisitBinaryExpr!(CiBinaryExpr# expr)
	{
		CiExpr# left = Resolve(expr.Left);
		CiExpr# right = Resolve(expr.Right);
		if (left == this.Poison || right == this.Poison)
			return this.Poison;
		CiType# type;

		switch (expr.Op) {
		case CiToken.LeftBracket:
			if (!(left.Type is CiClassType klass))
				return PoisonError(expr, "Cannot index this object");
			switch (klass.Class.Id) {
			case CiId.StringClass:
				Coerce(right, this.Program.System.IntType);
				if (left is CiLiteralString stringLiteral && right is CiLiteralLong indexLiteral) {
					long i = indexLiteral.Value;
					if (i >= 0 && i <= int.MaxValue) {
						int c = stringLiteral.GetAsciiAt(i);
						if (c >= 0)
							return CiLiteralChar.New(c, expr.Line);
					}
				}
				type = this.Program.System.CharType;
				break;
			case CiId.ArrayPtrClass:
			case CiId.ArrayStorageClass:
			case CiId.ListClass:
				Coerce(right, this.Program.System.IntType);
				type = klass.GetElementType();
				break;
			case CiId.DictionaryClass:
			case CiId.SortedDictionaryClass:
			case CiId.OrderedDictionaryClass:
				Coerce(right, klass.GetKeyType());
				type = klass.GetValueType();
				break;
			default:
				return PoisonError(expr, "Cannot index this object");
			}
			break;

		case CiToken.Plus:
			if (left.Type is CiRangeType leftAdd && right.Type is CiRangeType rightAdd) {
				type = CiRangeType.New(
					SaturatedAdd(leftAdd.Min, rightAdd.Min),
					SaturatedAdd(leftAdd.Max, rightAdd.Max));
			}
			else if (left.Type is CiStringType || right.Type is CiStringType) {
				Coerce(left, this.Program.System.PrintableType);
				Coerce(right, this.Program.System.PrintableType);
				if (left is CiLiteral leftLiteral && right is CiLiteral rightLiteral)
					return this.Program.System.NewLiteralString(leftLiteral.GetLiteralString() + rightLiteral.GetLiteralString(), expr.Line);
				if (left is CiInterpolatedString || right is CiInterpolatedString)
					return Concatenate(ToInterpolatedString(left), ToInterpolatedString(right));
				type = this.Program.System.StringStorageType;
			}
			else
				type = GetNumericType(left, right);
			break;
		case CiToken.Minus:
			if (left.Type is CiRangeType leftSub && right.Type is CiRangeType rightSub) {
				type = CiRangeType.New(
					SaturatedSub(leftSub.Min, rightSub.Max),
					SaturatedSub(leftSub.Max, rightSub.Min));
			}
			else
				type = GetNumericType(left, right);
			break;
		case CiToken.Asterisk:
			if (left.Type is CiRangeType leftMul && right.Type is CiRangeType rightMul) {
				type = NewRangeType(
					SaturatedMul(leftMul.Min, rightMul.Min),
					SaturatedMul(leftMul.Min, rightMul.Max),
					SaturatedMul(leftMul.Max, rightMul.Min),
					SaturatedMul(leftMul.Max, rightMul.Max));
			}
			else
				type = GetNumericType(left, right);
			break;
		case CiToken.Slash:
			if (left.Type is CiRangeType leftDiv && right.Type is CiRangeType rightDiv) {
				int denMin = rightDiv.Min;
				if (denMin == 0)
					denMin = 1;
				int denMax = rightDiv.Max;
				if (denMax == 0)
					denMax = -1;
				type = NewRangeType(
					SaturatedDiv(leftDiv.Min, denMin),
					SaturatedDiv(leftDiv.Min, denMax),
					SaturatedDiv(leftDiv.Max, denMin),
					SaturatedDiv(leftDiv.Max, denMax));
			}
			else
				type = GetNumericType(left, right);
			break;
		case CiToken.Mod:
			if (left.Type is CiRangeType leftMod && right.Type is CiRangeType rightMod) {
				int den = ~Math.Min(rightMod.Min, -rightMod.Max); // max(abs(rightRange))-1
				if (den < 0)
					return PoisonError(expr, "Mod zero");
				type = CiRangeType.New(
					leftMod.Min >= 0 ? 0 : Math.Max(leftMod.Min, -den),
					leftMod.Max < 0 ? 0 : Math.Min(leftMod.Max, den));
			}
			else
				type = GetIntegerType(left, right);
			break;

		case CiToken.And:
		case CiToken.Or:
		case CiToken.Xor:
			type = BitwiseOp(left, expr.Op, right);
			break;

		case CiToken.ShiftLeft:
			if (left.Type is CiRangeType leftShl && right.Type is CiRangeType rightShl && leftShl.Min == leftShl.Max && rightShl.Min == rightShl.Max) {
				// TODO: improve
				int result = leftShl.Min << rightShl.Min;
				type = CiRangeType.New(result, result);
			}
			else
				type = GetShiftType(left, right);
			break;
		case CiToken.ShiftRight:
			if (left.Type is CiRangeType leftShr && right.Type is CiRangeType rightShr) {
				if (rightShr.Min < 0)
					rightShr = CiRangeType.New(0, 32);
				type = CiRangeType.New(
					SaturatedShiftRight(leftShr.Min, leftShr.Min < 0 ? rightShr.Min : rightShr.Max),
					SaturatedShiftRight(leftShr.Max, leftShr.Max < 0 ? rightShr.Max : rightShr.Min));
			}
			else
				type = GetShiftType(left, right);
			break;

		case CiToken.Equal:
		case CiToken.NotEqual:
			return ResolveEquality(expr, left, right);
		case CiToken.Less:
			if (left.Type is CiRangeType leftLess && right.Type is CiRangeType rightLess) {
				if (leftLess.Max < rightLess.Min)
					return ToLiteralBool(expr, true);
				if (leftLess.Min >= rightLess.Max)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Program.System.BoolType;
			break;
		case CiToken.LessOrEqual:
			if (left.Type is CiRangeType leftLeq && right.Type is CiRangeType rightLeq) {
				if (leftLeq.Max <= rightLeq.Min)
					return ToLiteralBool(expr, true);
				if (leftLeq.Min > rightLeq.Max)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Program.System.BoolType;
			break;
		case CiToken.Greater:
			if (left.Type is CiRangeType leftGreater && right.Type is CiRangeType rightGreater) {
				if (leftGreater.Min > rightGreater.Max)
					return ToLiteralBool(expr, true);
				if (leftGreater.Max <= rightGreater.Min)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Program.System.BoolType;
			break;
		case CiToken.GreaterOrEqual:
			if (left.Type is CiRangeType leftGeq && right.Type is CiRangeType rightGeq) {
				if (leftGeq.Min >= rightGeq.Max)
					return ToLiteralBool(expr, true);
				if (leftGeq.Max < rightGeq.Min)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Program.System.BoolType;
			break;

		case CiToken.CondAnd:
			Coerce(left, this.Program.System.BoolType);
			Coerce(right, this.Program.System.BoolType);
			if (left is CiLiteralTrue)
				return right;
			if (left is CiLiteralFalse || right is CiLiteralTrue)
				return left;
			type = this.Program.System.BoolType;
			break;
		case CiToken.CondOr:
			Coerce(left, this.Program.System.BoolType);
			Coerce(right, this.Program.System.BoolType);
			if (left is CiLiteralTrue || right is CiLiteralFalse)
				return left;
			if (left is CiLiteralFalse)
				return right;
			type = this.Program.System.BoolType;
			break;

		case CiToken.Assign:
			CheckLValue(left);
			Coerce(right, left.Type);
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case CiToken.AddAssign:
			CheckLValue(left);
			if (left.Type.Id == CiId.StringStorageType)
				Coerce(right, this.Program.System.PrintableType);
			else {
				Coerce(left, this.Program.System.DoubleType);
				Coerce(right, left.Type);
			}
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case CiToken.SubAssign:
		case CiToken.MulAssign:
		case CiToken.DivAssign:
			CheckLValue(left);
			Coerce(left, this.Program.System.DoubleType);
			Coerce(right, left.Type);
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case CiToken.ModAssign:
		case CiToken.ShiftLeftAssign:
		case CiToken.ShiftRightAssign:
			CheckLValue(left);
			Coerce(left, this.Program.System.IntType);
			Coerce(right, this.Program.System.IntType);
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case CiToken.AndAssign:
		case CiToken.OrAssign:
		case CiToken.XorAssign:
			CheckLValue(left);
			if (!IsEnumOp(left, right)) {
				Coerce(left, this.Program.System.IntType);
				Coerce(right, this.Program.System.IntType);
			}
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case CiToken.Is:
			return ResolveIs(expr, left, right);

		case CiToken.Range:
			return PoisonError(expr, "Range within an expression");
		default:
			assert false;
		}
		if (type is CiRangeType range && range.Min == range.Max)
			return ToLiteralLong(expr, range.Min);
		return new CiBinaryExpr { Line = expr.Line, Left = left, Op = expr.Op, Right = right, Type = type };
	}

	CiType# TryGetPtr(CiType# type, bool nullable)
	{
		if (type.Id == CiId.StringStorageType)
			return nullable ? this.Program.System.StringNullablePtrType : this.Program.System.StringPtrType;
		if (type is CiStorageType storage)
			return new CiReadWriteClassType { Class = storage.Class.Id == CiId.ArrayStorageClass ? this.Program.System.ArrayPtrClass : storage.Class, Nullable = nullable, TypeArg0 = storage.TypeArg0, TypeArg1 = storage.TypeArg1 };
		if (nullable && type is CiClassType ptr && !ptr.Nullable) {
			CiClassType# result;
			if (type is CiDynamicPtrType)
				result = new CiDynamicPtrType();
			else if (type is CiReadWriteClassType)
				result = new CiReadWriteClassType();
			else
				result = new CiClassType();
			result.Class = ptr.Class;
			result.Nullable = true;
			result.TypeArg0 = ptr.TypeArg0;
			result.TypeArg1 = ptr.TypeArg1;
			return result;
		}
		return type;
	}

	static CiClass? GetLowestCommonAncestor(CiClass left, CiClass right)
	{
		for (;;) {
			if (left.IsSameOrBaseOf(right))
				return left;
			if (left.Parent is CiClass parent)
				left = parent;
			else
				return null;
		}
	}

	CiType# GetCommonType!(CiExpr left, CiExpr right)
	{
		if (left.Type is CiRangeType# leftRange && right.Type is CiRangeType# rightRange)
			return Union(leftRange, rightRange);
		bool nullable = left.Type.Nullable || right.Type.Nullable;
		CiType# ptr = TryGetPtr(left.Type, nullable);
		if (ptr.IsAssignableFrom(right.Type))
			return ptr;
		ptr = TryGetPtr(right.Type, nullable);
		if (ptr.IsAssignableFrom(left.Type))
			return ptr;
		if (left.Type is CiClassType leftClass && right.Type is CiClassType rightClass && leftClass.EqualTypeArguments(rightClass)) {
			CiClass? klass = GetLowestCommonAncestor(leftClass.Class, rightClass.Class);
			if (klass != null) {
				CiClassType# result;
				if (!(leftClass is CiReadWriteClassType) || !(rightClass is CiReadWriteClassType))
					result = new CiClassType();
				else if (leftClass is CiDynamicPtrType && rightClass is CiDynamicPtrType)
					result = new CiDynamicPtrType();
				else
					result = new CiReadWriteClassType();
				result.Class = klass;
				result.Nullable = nullable;
				result.TypeArg0 = leftClass.TypeArg0;
				result.TypeArg1 = leftClass.TypeArg1;
				return result;
			}
		}
		return PoisonError(left, $"Incompatible types: {left.Type} and {right.Type}");
	}

	CiExpr# VisitSelectExpr!(CiSelectExpr expr)
	{
		CiExpr# cond = ResolveBool(expr.Cond);
		CiExpr# onTrue = Resolve(expr.OnTrue);
		CiExpr# onFalse = Resolve(expr.OnFalse);
		CiType# type = GetCommonType(onTrue, onFalse);
		Coerce(onTrue, type);
		Coerce(onFalse, type);
		if (cond is CiLiteralTrue)
			return onTrue;
		if (cond is CiLiteralFalse)
			return onFalse;
		return new CiSelectExpr { Line = expr.Line, Cond = cond, OnTrue = onTrue, OnFalse = onFalse, Type = type };
	}

	CiType# EvalType(CiClassType generic, CiType# type)
	{
		if (type.Id == CiId.TypeParam0)
			return generic.TypeArg0;
		if (type.Id == CiId.TypeParam0NotFinal)
			return generic.TypeArg0.IsFinal() ? null : generic.TypeArg0;
		if (type is CiClassType collection && collection.Class.TypeParameterCount == 1 && collection.TypeArg0.Id == CiId.TypeParam0) {
			CiClassType# result = type is CiReadWriteClassType ? new CiReadWriteClassType() : new CiClassType();
			result.Class = collection.Class;
			result.TypeArg0 = generic.TypeArg0;
			return result;
		}
		return type;
	}

	bool CanCall(CiExpr? obj, CiMethod method, List<CiExpr#> arguments)
	{
		CiVar? param = method.Parameters.FirstParameter();
		foreach (CiExpr arg in arguments) {
			if (param == null)
				return false;
			CiType# type = param.Type;
			if (obj != null && obj.Type is CiClassType generic)
				type = EvalType(generic, type);
			if (!type.IsAssignableFrom(arg.Type))
				return false;
			param = param.NextParameter();
		}
		return param == null || param.Value != null;
	}

	CiExpr# ResolveCallWithArguments!(CiCallExpr# expr, List<CiExpr#> arguments)
	{
		if (!(Resolve(expr.Method) is CiSymbolReference# symbol))
			return this.Poison;
		CiMethod! method;
		switch (symbol.Symbol) {
		case null:
			return this.Poison;
		case CiMethod! m:
			method = m;
			break;
		case CiMethodGroup group:
			method = group.Methods[0];
			if (!CanCall(symbol.Left, method, arguments))
				method = group.Methods[1];
			break;
		default:
			return PoisonError(symbol, "Expected a method");
		}

		// TODO: check static
		int i = 0;
		for (CiVar? param = method.Parameters.FirstParameter(); param != null; param = param.NextParameter()) {
			CiType#? type = param.Type;
			if (symbol.Left != null && symbol.Left.Type is CiClassType generic) {
				type = EvalType(generic, type);
				if (type == null)
					continue;
			}
			if (i >= arguments.Count) {
				if (param.Value != null)
					break;
				return PoisonError(expr, $"Too few arguments for '{method.Name}'");
			}
			CiExpr! arg = arguments[i++];
			if (type.Id == CiId.TypeParam0Predicate && arg is CiLambdaExpr! lambda) {
				lambda.First.Type = symbol.Left.Type.AsClassType().TypeArg0;
				OpenScope(lambda);
				lambda.Body = Resolve(lambda.Body);
				CloseScope();
				Coerce(lambda.Body, this.Program.System.BoolType);
			}
			else
				Coerce(arg, type);
		}
		if (i < arguments.Count)
			return PoisonError(arguments[i], $"Too many arguments for '{method.Name}'");

		if (method.Throws) {
			if (this.CurrentMethod == null)
				return PoisonError(expr, $"Cannot call method '{method.Name}' here because it is marked 'throws'");
			if (!this.CurrentMethod.Throws)
				return PoisonError(expr, "Method marked 'throws' called from a method not marked 'throws'");
		}

		symbol.Symbol = method;

		if (method.CallType == CiCallType.Static
		 && method.Body is CiReturn ret
		 && arguments.All(arg => arg is CiLiteral)
		 && !this.CurrentPureMethods.Contains(method)) {
			this.CurrentPureMethods.Add(method);
			i = 0;
			for (CiVar? param = method.Parameters.FirstParameter(); param != null; param = param.NextParameter()) {
				if (i < arguments.Count)
					this.CurrentPureArguments[param] = arguments[i++];
				else
					this.CurrentPureArguments[param] = param.Value;
			}
			CiExpr# result = Resolve(ret.Value);
			for (CiVar? param = method.Parameters.FirstParameter(); param != null; param = param.NextParameter())
				this.CurrentPureArguments.Remove(param);
			this.CurrentPureMethods.Remove(method);
			if (result is CiLiteral)
				return result;
		}

		if (this.CurrentMethod != null)
			this.CurrentMethod.Calls.Add(method);
		if (this.CurrentPureArguments.Count == 0) {
			expr.Method = symbol;
			CiType# type = method.Type;
			if (symbol.Left != null && symbol.Left.Type is CiClassType generic)
				type = EvalType(generic, type);
			expr.Type = type;
		}
		return expr;
	}

	CiExpr# VisitCallExpr!(CiCallExpr# expr)
	{
		if (this.CurrentPureArguments.Count == 0) {
			List<CiExpr#>! arguments = expr.Arguments;
			for (int i = 0; i < arguments.Count; i++) {
				if (!(arguments[i] is CiLambdaExpr))
					arguments[i] = Resolve(arguments[i]);
			}
			return ResolveCallWithArguments(expr, arguments);
		}
		else {
			List<CiExpr#>() arguments;
			foreach (CiExpr# arg in expr.Arguments)
				arguments.Add(Resolve(arg));
			return ResolveCallWithArguments(expr, arguments);
		}
	}

	void ResolveObjectLiteral!(CiClassType klass, CiAggregateInitializer init)
	{
		foreach (CiExpr! item in init.Items) {
			assert item is CiBinaryExpr! field;
			assert field.Op == CiToken.Assign;
			assert field.Left is CiSymbolReference# symbol;
			Lookup(symbol, klass.Class);
			if (symbol.Symbol is CiField) {
				field.Right = Resolve(field.Right);
				Coerce(field.Right, symbol.Type);
			}
			else
				ReportError(field, "Expected a field");
		}
	}

	void VisitVar!(CiVar# expr)
	{
		CiType type = ResolveType(expr);
		if (expr.Value != null) {
			if (type is CiStorageType storage && expr.Value is CiAggregateInitializer init)
				ResolveObjectLiteral(storage, init);
			else {
				expr.Value = Resolve(expr.Value);
				if (!expr.IsAssignableStorage()) {
					if (type is CiArrayStorageType array) {
						type = array.GetElementType();
						if (!(expr.Value is CiLiteral literal) || !literal.IsDefaultValue())
							ReportError(expr.Value, "Only null, zero and false supported as an array initializer");
					}
					Coerce(expr.Value, type);
				}
			}
		}
		this.CurrentScope.Add(expr);
	}

	CiExpr# Resolve!(CiExpr# expr)
	{
		switch (expr) {
		case CiAggregateInitializer! aggregate:
			List<CiExpr#>! items = aggregate.Items;
			for (int i = 0; i < items.Count; i++)
				items[i] = Resolve(items[i]);
			return expr;
		case CiLiteral _:
			return expr;
		case CiInterpolatedString# interpolated:
			return VisitInterpolatedString(interpolated);
		case CiSymbolReference# symbol:
			return VisitSymbolReference(symbol);
		case CiPrefixExpr# prefix:
			return VisitPrefixExpr(prefix);
		case CiPostfixExpr# postfix:
			return VisitPostfixExpr(postfix);
		case CiBinaryExpr# binary:
			return VisitBinaryExpr(binary);
		case CiSelectExpr select:
			return VisitSelectExpr(select);
		case CiCallExpr# call:
			return VisitCallExpr(call);
		case CiLambdaExpr _:
			ReportError(expr, "Unexpected lambda expression");
			return expr;
		case CiVar# def:
			VisitVar(def);
			return expr;
		default:
			assert false;
		}
	}

	public override void VisitExpr!(CiExpr# statement)
	{
		Resolve(statement);
	}

	CiExpr# ResolveBool!(CiExpr# expr)
	{
		expr = Resolve(expr);
		Coerce(expr, this.Program.System.BoolType);
		return expr;
	}

	static CiClassType# CreateClassPtr(CiClass klass, CiToken ptrModifier, bool nullable)
	{
		CiClassType# ptr;
		switch (ptrModifier) {
		case CiToken.EndOfFile:
			ptr = new CiClassType();
			break;
		case CiToken.ExclamationMark:
			ptr = new CiReadWriteClassType();
			break;
		case CiToken.Hash:
			ptr = new CiDynamicPtrType();
			break;
		default:
			assert false;
		}
		ptr.Class = klass;
		ptr.Nullable = nullable;
		return ptr;
	}

	void FillGenericClass!(CiClassType! result, CiClass klass, CiAggregateInitializer typeArgExprs)
	{
		List<CiType#>() typeArgs;
		foreach (CiExpr# typeArgExpr in typeArgExprs.Items)
			typeArgs.Add(ToType(typeArgExpr, false));
		if (typeArgs.Count != klass.TypeParameterCount) {
			ReportError(result, $"Expected {klass.TypeParameterCount} type arguments for {klass.Name}, got {typeArgs.Count}");
			return;
		}
		result.Class = klass;
		result.TypeArg0 = typeArgs[0];
		if (typeArgs.Count == 2)
			result.TypeArg1 = typeArgs[1];
	}

	void ExpectNoPtrModifier!(CiExpr expr, CiToken ptrModifier, bool nullable)
	{
		if (ptrModifier != CiToken.EndOfFile)
			ReportError(expr, $"Unexpected {CiLexer.TokenToString(ptrModifier)} on a non-reference type");
		if (nullable)
			ReportError(expr, "Nullable value types not supported");
	}

	CiType# ToBaseType!(CiExpr expr, CiToken ptrModifier, bool nullable)
	{
		switch (expr) {
		case CiSymbolReference symbol:
			// built-in, string?, MyEnum, MyClass, MyClass?, MyClass!, MyClass!?, MyClass#, MyClass#?
			if (this.Program.TryLookup(symbol.Name, true) is CiType# type) {
				if (type is CiClass klass) {
					if (klass.Id == CiId.MatchClass && ptrModifier != CiToken.EndOfFile)
						ReportError(expr, "Read-write references to the built-in class Match are not supported");
					CiClassType# ptr = CreateClassPtr(klass, ptrModifier, nullable);
					if (symbol.Left is CiAggregateInitializer typeArgExprs)
						FillGenericClass(ptr, klass, typeArgExprs);
					else if (symbol.Left != null)
						return PoisonError(expr, "Invalid type");
					else
						ptr.Name = klass.Name; // TODO: needed?
					return ptr;
				}
				else if (symbol.Left != null)
					return PoisonError(expr, "Invalid type");
				if (type.Id == CiId.StringPtrType && nullable) {
					type = this.Program.System.StringNullablePtrType;
					nullable = false;
				}
				ExpectNoPtrModifier(expr, ptrModifier, nullable);
				return type;
			}
			return PoisonError(expr, $"Type {symbol.Name} not found");

		case CiCallExpr call:
			// string(), MyClass()
			ExpectNoPtrModifier(expr, ptrModifier, nullable);
			if (call.Arguments.Count != 0)
				ReportError(call, "Expected empty parentheses for storage type");
			if (call.Method.Left is CiAggregateInitializer typeArgExprs2) {
				CiStorageType# storage = new CiStorageType { Line = call.Line };
				if (this.Program.TryLookup(call.Method.Name, true) is CiClass klass) {
					FillGenericClass(storage, klass, typeArgExprs2);
					return storage;
				}
				return PoisonError(typeArgExprs2, $"{call.Method.Name} is not a class");
			}
			else if (call.Method.Left != null)
				return PoisonError(expr, "Invalid type");
			if (call.Method.Name == "string")
				return this.Program.System.StringStorageType;
			if (this.Program.TryLookup(call.Method.Name, true) is CiClass klass2)
				return new CiStorageType { Class = klass2 };
			return PoisonError(expr, $"Class {call.Method.Name} not found");

		default:
			return PoisonError(expr, "Invalid type");
		}
	}

	CiType# ToType!(CiExpr# expr, bool dynamic)
	{
		CiExpr#? minExpr = null;
		if (expr is CiBinaryExpr range && range.Op == CiToken.Range) {
			minExpr = range.Left;
			expr = range.Right;
		}

		bool nullable;
		CiToken ptrModifier;
		CiClassType#? outerArray = null; // leftmost in source
		CiClassType!? innerArray = null; // rightmost in source
		for (;;) {
			if (expr is CiPostfixExpr question && question.Op == CiToken.QuestionMark) {
				expr = question.Inner;
				nullable = true;
			}
			else
				nullable = false;
			if (expr is CiPostfixExpr postfix && (postfix.Op == CiToken.ExclamationMark || postfix.Op == CiToken.Hash)) {
				expr = postfix.Inner;
				ptrModifier = postfix.Op;
			}
			else
				ptrModifier = CiToken.EndOfFile;
			if (expr is CiBinaryExpr binary && binary.Op == CiToken.LeftBracket) {
				if (binary.Right != null) {
					ExpectNoPtrModifier(expr, ptrModifier, nullable);
					CiExpr# lengthExpr = Resolve(binary.Right);
					CiArrayStorageType# arrayStorage = new CiArrayStorageType { Class = this.Program.System.ArrayStorageClass, TypeArg0 = outerArray, LengthExpr = lengthExpr, Length = 0 };
					if (Coerce(lengthExpr, this.Program.System.IntType) && (!dynamic || binary.Left.IsIndexing())) {
						if (lengthExpr is CiLiteralLong literal) {
							long length = literal.Value;
							if (length < 0)
								ReportError(expr, "Expected non-negative integer");
							else if (length > int.MaxValue)
								ReportError(expr, "Integer too big");
							else
								arrayStorage.Length = length;
						}
						else
							ReportError(lengthExpr, "Expected constant value");
					}
					outerArray = arrayStorage;
				}
				else {
					CiType# elementType = outerArray;
					outerArray = CreateClassPtr(this.Program.System.ArrayPtrClass, ptrModifier, nullable);
					outerArray.TypeArg0 = elementType;
				}
				if (innerArray == null)
					innerArray = outerArray;
				expr = binary.Left;
			}
			else
				break;
		}

		CiType# baseType;
		if (minExpr != null) {
			ExpectNoPtrModifier(expr, ptrModifier, nullable);
			int min = FoldConstInt(minExpr);
			int max = FoldConstInt(expr);
			if (min > max)
				return PoisonError(expr, "Range min greater than max");
			baseType = CiRangeType.New(min, max);
		}
		else
			baseType = ToBaseType(expr, ptrModifier, nullable);
		baseType.Line = expr.Line;

		if (outerArray == null)
			return baseType;
		innerArray.TypeArg0 = baseType;
		return outerArray;
	}

	CiType# ResolveType!(CiNamedValue! def)
	{
		def.Type = ToType(def.TypeExpr, false);
		return def.Type;
	}

	public override void VisitAssert!(CiAssert! statement)
	{
		statement.Cond = ResolveBool(statement.Cond);
		if (statement.Message != null) {
			statement.Message = Resolve(statement.Message);
			if (!(statement.Message.Type is CiStringType))
				ReportError(statement, "The second argument of 'assert' must be a string");
		}
	}

	bool ResolveStatements!(List<CiStatement#> statements)
	{
		bool reachable = true;
		foreach (CiStatement# statement in statements) {
			if (statement is CiConst# konst) {
				ResolveConst(konst);
				this.CurrentScope.Add(konst);
				if (konst.Type is CiArrayStorageType) {
					assert this.CurrentScope.GetContainer() is CiClass! klass;
					klass.ConstArrays.Add(konst);
				}
			}
			else
				statement.AcceptStatement(this);
			if (!reachable) {
				ReportError(statement, "Unreachable statement");
				return false;
			}
			reachable = statement.CompletesNormally();
		}
		return reachable;
	}

	public override void VisitBlock!(CiBlock! statement)
	{
		OpenScope(statement);
		statement.SetCompletesNormally(ResolveStatements(statement.Statements));
		CloseScope();
	}

	public override void VisitBreak!(CiBreak! statement)
	{
		statement.LoopOrSwitch.SetCompletesNormally(true);
	}

	public override void VisitContinue!(CiContinue! statement)
	{
	}

	void ResolveLoopCond!(CiLoop! statement)
	{
		if (statement.Cond != null) {
			statement.Cond = ResolveBool(statement.Cond);
			statement.SetCompletesNormally(!(statement.Cond is CiLiteralTrue));
		}
		else
			statement.SetCompletesNormally(false);
	}

	public override void VisitDoWhile!(CiDoWhile! statement)
	{
		OpenScope(statement);
		ResolveLoopCond(statement);
		statement.Body.AcceptStatement(this);
		CloseScope();
	}

	public override void VisitFor!(CiFor! statement)
	{
		OpenScope(statement);
		if (statement.Init != null)
			statement.Init.AcceptStatement(this);
		ResolveLoopCond(statement);
		if (statement.Advance != null)
			statement.Advance.AcceptStatement(this);
		if (statement.Init is CiVar iter
			&& iter.Type is CiIntegerType
			&& iter.Value != null
			&& statement.Cond is CiBinaryExpr cond
			&& cond.Left.IsReferenceTo(iter)
			&& (cond.Right is CiLiteral || (cond.Right is CiSymbolReference limitSymbol && limitSymbol.Symbol is CiVar))) {
			long step = 0;
			switch (statement.Advance) {
			case CiUnaryExpr unary when unary.Inner != null && unary.Inner.IsReferenceTo(iter):
				switch (unary.Op) {
				case CiToken.Increment:
					step = 1;
					break;
				case CiToken.Decrement:
					step = -1;
					break;
				default:
					break;
				}
				break;
			case CiBinaryExpr binary when binary.Left.IsReferenceTo(iter) && binary.Right is CiLiteralLong literalStep:
				switch (binary.Op) {
				case CiToken.AddAssign:
					step = literalStep.Value;
					break;
				case CiToken.SubAssign:
					step = -literalStep.Value;
					break;
				default:
					break;
				}
				break;
			default:
				break;
			}
			if ((step > 0 && (cond.Op == CiToken.Less || cond.Op == CiToken.LessOrEqual))
			 || (step < 0 && (cond.Op == CiToken.Greater || cond.Op == CiToken.GreaterOrEqual))) {
				statement.IsRange = true;
				statement.RangeStep = step;
			}
			statement.IsIteratorUsed = false;
		}
		statement.Body.AcceptStatement(this);
		CloseScope();
	}

	public override void VisitForeach!(CiForeach! statement)
	{
		OpenScope(statement);
		CiVar! element = statement.GetVar();
		ResolveType(element);
		Resolve(statement.Collection);
		if (statement.Collection.Type is CiClassType klass) {
			switch (klass.Class.Id) {
			case CiId.StringClass:
				if (statement.Count() != 1 || !element.Type.IsAssignableFrom(this.Program.System.IntType))
					ReportError(statement, "Expected int iterator variable");
				break;
			case CiId.ArrayStorageClass:
			case CiId.ListClass:
			case CiId.HashSetClass:
			case CiId.SortedSetClass:
				if (statement.Count() != 1)
					ReportError(statement, "Expected one iterator variable");
				else if (!element.Type.IsAssignableFrom(klass.GetElementType()))
					ReportError(statement, $"Cannot coerce {klass.GetElementType()} to {element.Type}");
				break;
			case CiId.DictionaryClass:
			case CiId.SortedDictionaryClass:
			case CiId.OrderedDictionaryClass:
				if (statement.Count() != 2)
					ReportError(statement, "Expected (TKey key, TValue value) iterator");
				else {
					CiVar! value = statement.GetValueVar();
					ResolveType(value);
					if (!element.Type.IsAssignableFrom(klass.GetKeyType()))
						ReportError(statement, $"Cannot coerce {klass.GetKeyType()} to {element.Type}");
					else if (!value.Type.IsAssignableFrom(klass.GetValueType()))
						ReportError(statement, $"Cannot coerce {klass.GetValueType()} to {value.Type}");
				}
				break;
			default:
				ReportError(statement, $"'foreach' invalid on {klass.Class.Name}");
				break;
			}
		}
		else
			ReportError(statement, $"'foreach' invalid on {statement.Collection.Type}");
		statement.SetCompletesNormally(true);
		statement.Body.AcceptStatement(this);
		CloseScope();
	}

	public override void VisitIf!(CiIf! statement)
	{
		statement.Cond = ResolveBool(statement.Cond);
		statement.OnTrue.AcceptStatement(this);
		if (statement.OnFalse != null) {
			statement.OnFalse.AcceptStatement(this);
			statement.SetCompletesNormally(statement.OnTrue.CompletesNormally() || statement.OnFalse.CompletesNormally());
		}
		else
			statement.SetCompletesNormally(true);
	}

	public override void VisitLock!(CiLock! statement)
	{
		statement.Lock = Resolve(statement.Lock);
		Coerce(statement.Lock, this.Program.System.LockPtrType);
		statement.Body.AcceptStatement(this);
	}

	public override void VisitNative!(CiNative! statement)
	{
	}

	public override void VisitReturn!(CiReturn! statement)
	{
		if (this.CurrentMethod.Type.Id == CiId.VoidType) {
			if (statement.Value != null)
				ReportError(statement, "Void method cannot return a value");
		}
		else if (statement.Value == null)
			ReportError(statement, "Missing return value");
		else {
			statement.Value = Resolve(statement.Value);
			Coerce(statement.Value, this.CurrentMethod.Type);
			if (statement.Value is CiSymbolReference symbol
			 && symbol.Symbol is CiVar local
			 && ((local.Type.IsFinal() && !(this.CurrentMethod.Type is CiStorageType))
				|| (local.Type.Id == CiId.StringStorageType && this.CurrentMethod.Type.Id != CiId.StringStorageType)))
				ReportError(statement, "Returning dangling reference to local storage");
		}
	}

	public override void VisitSwitch!(CiSwitch! statement)
	{
		OpenScope(statement);
		statement.Value = Resolve(statement.Value);
		switch (statement.Value.Type) {
		case CiIntegerType i when i.Id != CiId.LongType:
		case CiEnum _:
		// case CiStringType _: matched by case CiClassType
			break;
		case CiClassType klass when !(klass is CiStorageType):
			break;
		default:
			ReportError(statement.Value, $"Switch on type {statement.Value.Type} - expected int, enum, string or object reference");
			return;
		}
		statement.SetCompletesNormally(false);
		foreach (CiCase! kase in statement.Cases) {
			for (int i = 0; i < kase.Values.Count; i++) {
				if (statement.Value.Type is CiClassType switchPtr && switchPtr.Class.Id != CiId.StringClass) {
					CiExpr# value = kase.Values[i];
					if (value is CiBinaryExpr when1 && when1.Op == CiToken.When)
						value = when1.Left;
					if (value is CiLiteralNull) {
					}
					else if (!(value is CiVar# def) || def.Value != null)
						ReportError(kase.Values[i], "Expected 'case Type name'");
					else if (!(ResolveType(def) is CiClassType casePtr) || casePtr is CiStorageType)
						ReportError(def, "'case' with non-reference type");
					else if (casePtr is CiReadWriteClassType
					 && !(switchPtr is CiDynamicPtrType)
					 && (casePtr is CiDynamicPtrType || !(switchPtr is CiReadWriteClassType)))
						ReportError(def, $"{switchPtr} cannot be casted to {casePtr}");
					else if (casePtr.Class.IsSameOrBaseOf(switchPtr.Class))
						ReportError(def, $"{statement.Value} is {switchPtr}, 'case {casePtr}' would always match");
					else if (!switchPtr.Class.IsSameOrBaseOf(casePtr.Class))
						ReportError(def, $"{switchPtr} is not base class of {casePtr.Class.Name}, 'case {casePtr}' would never match");
					else {
						statement.Add(def);
						if (kase.Values[i] is CiBinaryExpr! when2 && when2.Op == CiToken.When)
							when2.Right = ResolveBool(when2.Right);
					}
				}
				else {
					kase.Values[i] = FoldConst(kase.Values[i]);
					Coerce(kase.Values[i], statement.Value.Type);
				}
			}
			if (ResolveStatements(kase.Body))
				ReportError(kase.Body.Last(), "Case must end with break, continue, return or throw");
		}
		if (statement.DefaultBody.Count > 0) {
			bool reachable = ResolveStatements(statement.DefaultBody);
			if (reachable)
				ReportError(statement.DefaultBody.Last(), "Default must end with break, continue, return or throw");
		}
		CloseScope();
	}

	public override void VisitThrow!(CiThrow! statement)
	{
		if (!this.CurrentMethod.Throws)
			ReportError(statement, "'throw' in a method not marked 'throws'");
		statement.Message = Resolve(statement.Message);
		if (!(statement.Message.Type is CiStringType))
			ReportError(statement, "The argument of 'throw' must be a string");
	}

	public override void VisitWhile!(CiWhile! statement)
	{
		OpenScope(statement);
		ResolveLoopCond(statement);
		statement.Body.AcceptStatement(this);
		CloseScope();
	}

	CiExpr# FoldConst!(CiExpr# expr)
	{
		expr = Resolve(expr);
		if (expr is CiLiteral || expr.IsConstEnum())
			return expr;
		ReportError(expr, "Expected constant value");
		return expr;
	}

	int FoldConstInt!(CiExpr# expr)
	{
		if (FoldConst(expr) is CiLiteralLong literal) {
			long l = literal.Value;
			if (l < int.MinValue || l > int.MaxValue) {
				ReportError(expr, "Only 32-bit ranges supported");
				return 0;
			}
			return l;
		}
		ReportError(expr, "Expected integer");
		return 0;
	}

	void ResolveTypes!(CiClass! klass)
	{
		this.CurrentScope = klass;
		for (CiSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			switch (symbol) {
			case CiField! field:
				CiType! type = ResolveType(field);
				if (field.Value != null) {
					field.Value = Resolve(field.Value);
					if (!field.IsAssignableStorage())
						Coerce(field.Value, type is CiArrayStorageType array ? array.GetElementType() : type);
				}
				break;
			case CiMethod! method:
				if (method.TypeExpr == this.Program.System.VoidType)
					method.Type = this.Program.System.VoidType;
				else
					ResolveType(method);
				for (CiVar!? param = method.Parameters.FirstParameter(); param != null; param = param.NextParameter()) {
					ResolveType(param);
					if (param.Value != null) {
						param.Value = FoldConst(param.Value);
						Coerce(param.Value, param.Type);
					}
				}
				if (method.CallType == CiCallType.Override || method.CallType == CiCallType.Sealed) {
					if (klass.Parent.TryLookup(method.Name, false) is CiMethod! baseMethod) {
						// TODO: check private
						switch (baseMethod.CallType) {
						case CiCallType.Abstract:
						case CiCallType.Virtual:
						case CiCallType.Override:
							break;
						default:
							ReportError(method, "Base method is not abstract or virtual");
							break;
						}
						if (!method.Type.EqualsType(baseMethod.Type))
							ReportError(method, "Base method has a different return type");
						if (method.IsMutator != baseMethod.IsMutator) {
							if (method.IsMutator)
								ReportError(method, "Mutating method cannot override a non-mutating method");
							else
								ReportError(method, "Non-mutating method cannot override a mutating method");
						}
						CiVar? baseParam = baseMethod.Parameters.FirstParameter();
						for (CiVar? param = method.Parameters.FirstParameter(); ; param = param.NextParameter()) {
							if (param == null) {
								if (baseParam != null)
									ReportError(method, "Fewer parameters than the overridden method");
								break;
							}
							if (baseParam == null) {
								ReportError(method, "More parameters than the overridden method");
								break;
							}
							if (!param.Type.EqualsType(baseParam.Type)) {
								ReportError(method, "Base method has a different parameter type");
								break;
							}
							baseParam = baseParam.NextParameter();
						}
						baseMethod.Calls.Add(method);
					}
					else
						ReportError(method, "No method to override");
				}
				break;
			default:
				break;
			}
		}
	}

	void ResolveConst!(CiConst! konst)
	{
		switch (konst.VisitStatus) {
		case CiVisitStatus.NotYet:
			break;
		case CiVisitStatus.InProgress:
			konst.Value = PoisonError(konst, $"Circular dependency in value of constant {konst.Name}");
			konst.VisitStatus = CiVisitStatus.Done;
			return;
		case CiVisitStatus.Done:
			return;
		}
		konst.VisitStatus = CiVisitStatus.InProgress;
		if (!(this.CurrentScope is CiEnum))
			ResolveType(konst);
		konst.Value = Resolve(konst.Value);
		if (konst.Value is CiAggregateInitializer! coll) {
			if (konst.Type is CiClassType array) {
				CiType# elementType = array.GetElementType();
				if (array is CiArrayStorageType arrayStg) {
					if (arrayStg.Length != coll.Items.Count)
						ReportError(konst, $"Declared {arrayStg.Length} elements, initialized {coll.Items.Count}");
				}
				else if (array is CiReadWriteClassType)
					ReportError(konst, "Invalid constant type");
				else
					konst.Type = new CiArrayStorageType { Class = this.Program.System.ArrayStorageClass, TypeArg0 = elementType, Length = coll.Items.Count };
				coll.Type = konst.Type;
				foreach (CiExpr item in coll.Items)
					Coerce(item, elementType);
			}
			else
				ReportError(konst, $"Array initializer for scalar constant {konst.Name}");
		}
		else if (this.CurrentScope is CiEnum && konst.Value.Type is CiRangeType && konst.Value is CiLiteral) {
		}
		else if (konst.Value is CiLiteral || konst.Value.IsConstEnum())
			Coerce(konst.Value, konst.Type);
		else if (konst.Value != this.Poison)
			ReportError(konst.Value, $"Value for constant {konst.Name} is not constant");
		konst.InMethod = this.CurrentMethod;
		konst.VisitStatus = CiVisitStatus.Done;
	}

	public override void VisitConst!(CiConst statement)
	{
	}

	public override void VisitEnumValue!(CiConst! konst, CiConst? previous)
	{
		if (konst.Value != null) {
			ResolveConst(konst);
			assert konst.Parent is CiEnum! enu;
			enu.HasExplicitValue = true;
		}
		else
			konst.Value = new CiImplicitEnumValue { Value = previous == null ? 0 : previous.Value.IntValue() + 1 };
	}

	void ResolveConsts!(CiContainerType! container)
	{
		this.CurrentScope = container;
		switch (container) {
		case CiClass klass:
			for (CiSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
				if (symbol is CiConst! konst)
					ResolveConst(konst);
			}
			break;
		case CiEnum enu:
			enu.AcceptValues(this);
			break;
		default:
			assert false;
		}
	}

	void ResolveCode!(CiClass! klass)
	{
		if (klass.Constructor != null) {
			this.CurrentScope = klass;
			this.CurrentMethod = klass.Constructor;
			klass.Constructor.Body.AcceptStatement(this);
			this.CurrentMethod = null;
		}
		for (CiSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			if (symbol is CiMethod! method) {
				if (method.Name == "ToString" && method.CallType != CiCallType.Static && method.Parameters.Count() == 0)
					method.Id = CiId.ClassToString;
				if (method.Body != null) {
					this.CurrentScope = method.Parameters;
					this.CurrentMethod = method;
					if (!(method.Body is CiScope))
						OpenScope(method.MethodScope); // don't add "is Derived d" to parameters
					method.Body.AcceptStatement(this);
					if (method.Type.Id != CiId.VoidType && method.Body.CompletesNormally())
						ReportError(method.Body, "Method can complete without a return value");
					this.CurrentMethod = null;
				}
			}
		}
	}

	static void MarkMethodLive(CiMethodBase! method)
	{
		if (method.IsLive)
			return;
		method.IsLive = true;
		foreach (CiMethod! called in method.Calls)
			MarkMethodLive(called);
	}

	static void MarkClassLive(CiClass klass)
	{
		if (!klass.IsPublic)
			return;
		for (CiSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			if (symbol is CiMethod! method
			 && (method.Visibility == CiVisibility.Public || method.Visibility == CiVisibility.Protected))
				MarkMethodLive(method);
		}
		if (klass.Constructor != null)
			MarkMethodLive(klass.Constructor);
	}

	public void Process!(CiProgram! program)
	{
		this.Program = program;
		for (CiSymbol!? type = program.First; type != null; type = type.Next) {
			if (type is CiClass! klass)
				ResolveBase(klass);
		}
		foreach (CiClass! klass in program.Classes)
			CheckBaseCycle(klass);
		for (CiSymbol!? type = program.First; type != null; type = type.Next) {
			assert type is CiContainerType! container;
			ResolveConsts(container);
		}
		foreach (CiClass! klass in program.Classes)
			ResolveTypes(klass);
		foreach (CiClass! klass in program.Classes)
			ResolveCode(klass);
		foreach (CiClass klass in program.Classes)
			MarkClassLive(klass);
	}
}
