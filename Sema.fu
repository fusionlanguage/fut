// Sema.fu - semantic analysis of Fusion
//
// Copyright (C) 2011-2024  Piotr Fusik
//
// This file is part of Fusion Transpiler,
// see https://github.com/fusionlanguage/fut
//
// Fusion Transpiler is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Fusion Transpiler is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Fusion Transpiler.  If not, see http://www.gnu.org/licenses/

public abstract class FuSemaHost : FuParserHost
{
	internal virtual int GetResourceLength!(string name, FuPrefixExpr expr) => 0;
}

public class FuSema
{
	FuSemaHost! Host;
	FuMethodBase!? CurrentMethod = null;
	FuScope!? CurrentScope;
	HashSet<FuMethod>() CurrentPureMethods;
	Dictionary<FuVar, FuExpr#>() CurrentPureArguments;
	FuType# Poison = new FuType { Name = "poison" };

	public void SetHost!(FuSemaHost! host)
	{
		this.Host = host;
	}

	void ReportError(FuStatement statement, string message)
	{
		this.Host.ReportStatementError(statement, message);
	}

	FuType# PoisonError(FuStatement statement, string message)
	{
		ReportError(statement, message);
		return this.Poison;
	}

	void ResolveBase!(FuClass! klass)
	{
		if (klass.HasBaseClass()) {
			this.CurrentScope = klass;
			if (this.Host.Program.TryLookup(klass.BaseClass.Name, true) is FuClass! baseClass) {
				if (klass.IsPublic && !baseClass.IsPublic)
					ReportError(klass.BaseClass, "Public class cannot derive from an internal class");
				klass.BaseClass.Symbol = baseClass;
				baseClass.HasSubclasses = true;
				klass.Parent = baseClass;
			}
			else
				ReportError(klass.BaseClass, $"Base class '{klass.BaseClass.Name}' not found");
		}
		this.Host.Program.Classes.Add(klass);
	}

	void CheckBaseCycle!(FuClass! klass)
	{
		// Floyd's tortoise and hare cycle-finding algorithm
		FuSymbol? hare = klass;
		FuSymbol tortoise = klass;
		do {
			hare = hare.Parent;
			if (hare == null)
				return;
			if (hare.Id == FuId.ExceptionClass)
				klass.Id = FuId.ExceptionClass;
			hare = hare.Parent;
			if (hare == null)
				return;
			if (hare.Id == FuId.ExceptionClass)
				klass.Id = FuId.ExceptionClass;
			tortoise = tortoise.Parent;
		} while (tortoise != hare);
		this.CurrentScope = klass;
		ReportError(klass, $"Circular inheritance for class '{klass.Name}'");
	}

	static void TakePtr(FuExpr expr)
	{
		if (expr.Type is FuArrayStorageType! arrayStg)
			arrayStg.PtrTaken = true;
	}

	bool Coerce(FuExpr expr, FuType type)
	{
		if (expr == this.Poison || type == this.Poison)
			return false;
		if (!type.IsAssignableFrom(expr.Type)) {
			ReportError(expr, $"Cannot convert '{expr.Type}' to '{type}'");
			return false;
		}
		if (expr is FuPrefixExpr prefix && prefix.Op == FuToken.New && !(type is FuDynamicPtrType)) {
			assert expr.Type is FuDynamicPtrType newType;
			string kind = newType.Class.Id == FuId.ArrayPtrClass ? "array" : "object";
			ReportError(expr, $"Dynamically allocated {kind} must be assigned to a '{expr.Type}' reference");
			return false;
		}
		TakePtr(expr);
		return true;
	}

	bool CoercePermanent(FuExpr expr, FuType type)
	{
		bool ok = Coerce(expr, type);
		if (ok && type.Id == FuId.StringPtrType && expr.IsNewString(true)) {
			ReportError(expr, "New string must be assigned to 'string()'");
			return false;
		}
		return ok;
	}

	FuExpr# VisitInterpolatedString!(FuInterpolatedString# expr)
	{
		int partsCount = 0;
		string() s = "";
		for (int partsIndex = 0; partsIndex < expr.Parts.Count; partsIndex++) {
			FuInterpolatedPart part = expr.Parts[partsIndex];
			s += part.Prefix;
			FuExpr# arg = VisitExpr(part.Argument);
			if (Coerce(arg, this.Host.Program.System.PrintableType)) {
				switch (arg.Type) {
				case FuIntegerType:
					switch (part.Format) {
					case ' ':
						if (arg is FuLiteralLong literalLong && part.WidthExpr == null) {
							s += $"{literalLong.Value}";
							continue;
						}
						break;
					case 'D':
					case 'd':
					case 'X':
					case 'x':
						if (part.WidthExpr != null && part.Precision >= 0)
							ReportError(part.WidthExpr, "Cannot format an integer with both width and precision");
						break;
					default:
						ReportError(arg, "Invalid format");
						break;
					}
					break;
				case FuFloatingType:
					switch (part.Format) {
					case ' ':
					case 'F':
					case 'f':
					case 'E':
					case 'e':
						break;
					default:
						ReportError(arg, "Invalid format");
						break;
					}
					break;
				default:
					if (part.Format != ' ')
						ReportError(arg, "Invalid format");
					else if (arg is FuLiteralString literalString && part.WidthExpr == null) {
						s += literalString.Value;
						continue;
					}
					break;
				}
			}
			FuInterpolatedPart! targetPart = expr.Parts[partsCount++];
			targetPart.Prefix = s;
			targetPart.Argument = arg;
			targetPart.WidthExpr = part.WidthExpr;
			targetPart.Width = part.WidthExpr != null ? FoldConstInt(part.WidthExpr) : 0;
			targetPart.Format = part.Format;
			targetPart.Precision = part.Precision;
			s = "";
		}
		s += expr.Suffix;
		if (partsCount == 0)
			return this.Host.Program.System.NewLiteralString(s, expr.Loc);
		expr.Type = this.Host.Program.System.StringStorageType;
		expr.Parts.RemoveRange(partsCount, expr.Parts.Count - partsCount);
		expr.Suffix = s;
		return expr;
	}

	FuExpr# Lookup!(FuSymbolReference# expr, FuScope scope)
	{
		if (expr.Symbol == null) {
			expr.Symbol = scope.TryLookup(expr.Name, expr.Left == null);
			if (expr.Symbol == null)
				return PoisonError(expr, $"'{expr.Name}' not found");
			expr.Type = expr.Symbol.Type;
		}
		if (!(scope is FuEnum) && expr.Symbol is FuConst! konst) {
			ResolveConst(konst);
			if (konst.Value is FuLiteral || konst.Value is FuSymbolReference) {
				if (konst.Type is FuFloatingType && konst.Value is FuLiteralLong intValue)
					return ToLiteralDouble(expr, intValue.Value);
				return konst.Value;
			}
		}
		return expr;
	}

	FuContainerType! GetCurrentContainer() // TODO: refactor to this.CurrentMethod.Parent ?
	{
		for (FuScope!? scope = this.CurrentScope; scope != null; scope = scope.Parent) {
			if (scope is FuContainerType! container)
				return container;
		}
		assert false;
	}

	FuExpr# VisitSymbolReference!(FuSymbolReference# expr)
	{
		if (expr.Left == null) {
			FuExpr# resolved = Lookup(expr, this.CurrentScope);
			if (expr.Symbol is FuMember nearMember) {
				if (nearMember.Visibility == FuVisibility.Private
				 && nearMember.Parent is FuClass memberClass // not local const
				 && memberClass != GetCurrentContainer())
					ReportError(expr, $"Cannot access private member '{expr.Name}'");
				if (!nearMember.IsStatic()
				 && (this.CurrentMethod == null || this.CurrentMethod.IsStatic()))
					ReportError(expr, $"Cannot use instance member '{expr.Name}' from static context");
			}
			if (resolved is FuSymbolReference symbol) {
				if (symbol.Symbol is FuVar v) {
					if (v.Parent is FuFor! loop)
						loop.IsIndVarUsed = true;
					else if (this.CurrentPureArguments.ContainsKey(v)) // TryGetValue
						return this.CurrentPureArguments[v];
				}
				else if (symbol.Symbol.Id == FuId.RegexOptionsEnum)
					this.Host.Program.RegexOptionsEnum = true;
			}
			return resolved;
		}

		FuExpr# left = VisitExpr(expr.Left);
		if (left == this.Poison)
			return left;
		FuScope scope;
		bool isBase = left is FuSymbolReference baseSymbol && baseSymbol.Symbol.Id == FuId.BasePtr;
		if (isBase) {
			if (this.CurrentMethod == null)
				return PoisonError(left, "'base' invalid outside methods");
			if (this.CurrentMethod.IsStatic())
				return PoisonError(left, "'base' invalid in static context");
			if (!(this.CurrentMethod.Parent.Parent is FuClass baseClass))
				return PoisonError(left, "No base class");
			scope = baseClass;
		}
		else if (left is FuSymbolReference leftSymbol && leftSymbol.Symbol is FuScope obj)
			scope = obj;
		else {
			scope = left.Type;
			if (scope is FuClassType klass)
				scope = klass.Class;
		}
		FuExpr# result = Lookup(expr, scope);
		if (expr.Symbol is FuMember member) {
			switch (member.Visibility) {
			case FuVisibility.Private:
				if (member.Parent != this.CurrentMethod.Parent
				 || this.CurrentMethod.Parent != scope) // enforced by Java, but not C++/C#/TS
					ReportError(expr, $"Cannot access private member '{expr.Name}'");
				break;
			case FuVisibility.Protected:
				if (isBase)
					break;
				assert this.CurrentMethod.Parent is FuClass currentClass;
				assert scope is FuClass scopeClass;
				if (!currentClass.IsSameOrBaseOf(scopeClass)) // enforced by C++/C#/TS but not Java
					ReportError(expr, $"Cannot access protected member '{expr.Name}'");
				break;
			case FuVisibility.NumericElementType:
				if (left.Type is FuClassType klass && !(klass.GetElementType() is FuNumericType))
					ReportError(expr, "Method restricted to collections of numbers");
				break;
			case FuVisibility.FinalValueType: // DictionaryAdd
				if (!left.Type.AsClassType().GetValueType().IsFinal())
					ReportError(expr, "Method restricted to dictionaries with storage values");
				break;
			default:
				switch (expr.Symbol.Id) {
				case FuId.ArrayLength:
					if (left.Type is FuArrayStorageType arrayStorage)
						return ToLiteralLong(expr, arrayStorage.Length);
					break;
				case FuId.StringLength:
					if (left is FuLiteralString leftLiteral) {
						int length = leftLiteral.GetAsciiLength();
						if (length >= 0)
							return ToLiteralLong(expr, length);
					}
					break;
				default:
					break;
				}
				break;
			}
			if (!(member is FuMethodGroup)) {
				if (left is FuSymbolReference leftType && leftType.Symbol is FuType) {
					if (!member.IsStatic())
						ReportError(expr, $"Cannot use instance member '{expr.Name}' without an object");
				}
				else if (member.IsStatic())
					ReportError(expr, $"'{expr.Name}' is static");
			}
		}
		if (result != expr)
			return result;
		return new FuSymbolReference { Loc = expr.Loc, Left = left, Name = expr.Name, Symbol = expr.Symbol, Type = expr.Type };
	}

	static FuRangeType# Union(FuRangeType# left, FuRangeType#? right)
	{
		if (right == null)
			return left;
		if (right.Min < left.Min) {
			if (right.Max >= left.Max)
				return right;
			return FuRangeType.New(right.Min, left.Max);
		}
		if (right.Max > left.Max)
			return FuRangeType.New(left.Min, right.Max);
		return left;
	}

	FuType# GetIntegerType(FuExpr left, FuExpr right)
	{
		FuType# type = this.Host.Program.System.PromoteIntegerTypes(left.Type, right.Type);
		Coerce(left, type);
		Coerce(right, type);
		return type;
	}

	FuType# GetShiftType(FuExpr left, FuExpr right)
	{
		FuIntegerType# intType = this.Host.Program.System.IntType;
		Coerce(left, intType);
		Coerce(right, intType);
		return left.Type is FuRangeType ? intType : left.Type;
	}

	FuType# GetNumericType(FuExpr left, FuExpr right)
	{
		FuType# type = this.Host.Program.System.PromoteNumericTypes(left.Type, right.Type);
		Coerce(left, type);
		Coerce(right, type);
		return type;
	}

	static int SaturatedNeg(int a)
	{
		if (a == int.MinValue)
			return int.MaxValue;
		return -a;
	}

	static int SaturatedAdd(int a, int b)
	{
		int c = a + b;
		if (c >= 0) {
			if (a < 0 && b < 0)
				return int.MinValue;
		}
		else if (a > 0 && b > 0)
			return int.MaxValue;
		return c;
	}

	static int SaturatedSub(int a, int b)
	{
		if (b == int.MinValue)
			return a < 0 ? a ^ b : int.MaxValue;
		return SaturatedAdd(a, -b);
	}

	static int SaturatedMul(int a, int b)
	{
		if (a == 0 || b == 0)
			return 0;
		if (a == int.MinValue)
			return b >> 31 ^ a;
		if (b == int.MinValue)
			return a >> 31 ^ b;
		if (int.MaxValue / Math.Abs(a) < Math.Abs(b))
			return (a ^ b) >> 31 ^ int.MaxValue;
		return a * b;
	}

	static int SaturatedDiv(int a, int b)
	{
		if (a == int.MinValue && b == -1)
			return int.MaxValue;
		return a / b;
	}

	static int SaturatedShiftRight(int a, int b) => a >> (b >= 31 || b < 0 ? 31 : b);

	static FuRangeType# BitwiseUnsignedOp(FuRangeType left, FuToken op, FuRangeType right)
	{
		int leftVariableBits = left.GetVariableBits();
		int rightVariableBits = right.GetVariableBits();
		int min;
		int max;
		switch (op) {
		case FuToken.And:
			min = left.Min & right.Min & ~FuRangeType.GetMask(~left.Min & ~right.Min & (leftVariableBits | rightVariableBits));
			// Calculate upper bound with variable bits set
			max = (left.Max | leftVariableBits) & (right.Max | rightVariableBits);
			// The upper bound will never exceed the input
			if (max > left.Max)
				max = left.Max;
			if (max > right.Max)
				max = right.Max;
			break;
		case FuToken.Or:
			min = (left.Min & ~leftVariableBits) | (right.Min & ~rightVariableBits);
			max = left.Max | right.Max | FuRangeType.GetMask(left.Max & right.Max & FuRangeType.GetMask(leftVariableBits | rightVariableBits));
			// The lower bound will never be less than the input
			if (min < left.Min)
				min = left.Min;
			if (min < right.Min)
				min = right.Min;
			break;
		case FuToken.Xor:
			int variableBits = leftVariableBits | rightVariableBits;
			min = (left.Min ^ right.Min) & ~variableBits;
			max = (left.Max ^ right.Max) | variableBits;
			break;
		default:
			assert false;
		}
		if (min > max)
			return FuRangeType.New(max, min); // FIXME: this is wrong! e.g. min=0 max=0x8000000_00000000 then 5 should be in range
		return FuRangeType.New(min, max);
	}

	bool IsEnumOp(FuExpr left, FuExpr right)
	{
		if (left.Type is FuEnum) {
			if (left.Type.Id != FuId.BoolType && !(left.Type is FuEnumFlags))
				ReportError(left, $"Define flags enumeration as 'enum* {left.Type}'");
			Coerce(right, left.Type);
			return true;
		}
		return false;
	}

	FuType# BitwiseOp(FuExpr left, FuToken op, FuExpr right)
	{
		if (left.Type is FuRangeType# leftRange && right.Type is FuRangeType# rightRange) {
			FuRangeType#? range = null;
			FuRangeType#? rightNegative;
			FuRangeType#? rightPositive;
			if (rightRange.Min >= 0) {
				rightNegative = null;
				rightPositive = rightRange;
			}
			else if (rightRange.Max < 0) {
				rightNegative = rightRange;
				rightPositive = null;
			}
			else {
				rightNegative = FuRangeType.New(rightRange.Min, -1);
				rightPositive = FuRangeType.New(0, rightRange.Max);
			}
			if (leftRange.Min < 0) {
				FuRangeType leftNegative = leftRange.Max < 0 ? leftRange : FuRangeType.New(leftRange.Min, -1);
				if (rightNegative != null)
					range = BitwiseUnsignedOp(leftNegative, op, rightNegative);
				if (rightPositive != null)
					range = Union(BitwiseUnsignedOp(leftNegative, op, rightPositive), range);
			}
			if (leftRange.Max >= 0) {
				FuRangeType leftPositive = leftRange.Min >= 0 ? leftRange : FuRangeType.New(0, leftRange.Max);
				if (rightNegative != null)
					range = Union(BitwiseUnsignedOp(leftPositive, op, rightNegative), range);
				if (rightPositive != null)
					range = Union(BitwiseUnsignedOp(leftPositive, op, rightPositive), range);
			}
			return range;
		}
		if (IsEnumOp(left, right))
			return left.Type;
		return GetIntegerType(left, right);
	}

	static FuRangeType# NewRangeType(int a, int b, int c, int d)
	{
		if (a > b) {
			int t = a;
			a = b;
			b = t;
		}
		if (c > d) {
			int t = c;
			c = d;
			d = t;
		}
		return FuRangeType.New(a <= c ? a : c, b >= d ? b : d);
	}

	FuLiteral# ToLiteralBool(FuExpr expr, bool value)
	{
		FuLiteral# result = value ? new FuLiteralTrue() : new FuLiteralFalse();
		result.Loc = expr.Loc;
		result.Type = this.Host.Program.System.BoolType;
		return result;
	}

	FuLiteralLong# ToLiteralLong(FuExpr expr, long value) => this.Host.Program.System.NewLiteralLong(value, expr.Loc);

	FuLiteralDouble# ToLiteralDouble(FuExpr expr, double value) => new FuLiteralDouble { Loc = expr.Loc, Type = this.Host.Program.System.DoubleType, Value = value };

	void CheckLValue(FuExpr expr)
	{
		switch (expr) {
		case FuSymbolReference symbol:
			switch (symbol.Symbol) {
			case FuVar! def:
				def.IsAssigned = true;
				switch (symbol.Symbol.Parent) {
				case FuFor! forLoop:
					forLoop.IsRange = false;
					break;
				case FuForeach:
					ReportError(expr, "Cannot assign a foreach iteration variable");
					break;
				default:
					break;
				}
				for (FuScope! scope = this.CurrentScope; !(scope is FuClass); scope = scope.Parent) {
					if (scope is FuFor! forLoop
					 && forLoop.IsRange
					 && forLoop.Cond is FuBinaryExpr binaryCond
					 && binaryCond.Right.IsReferenceTo(symbol.Symbol))
						forLoop.IsRange = false;
				}
				break;
			case FuField:
				if (symbol.Left == null) {
					if (!this.CurrentMethod.IsMutator())
						ReportError(expr, "Cannot modify field in a non-mutating method");
				}
				else {
					switch (symbol.Left.Type) {
					case FuStorageType:
						// TODO
						break;
					case FuReadWriteClassType:
						break;
					case FuClassType:
						ReportError(expr, "Cannot modify field through a read-only reference");
						break;
					default:
						assert false;
					}
				}
				break;
			default:
				ReportError(expr, "Cannot modify this");
				break;
			}
			break;
		case FuBinaryExpr indexing when indexing.Op == FuToken.LeftBracket:
			switch (indexing.Left.Type) {
			case FuStorageType:
				// TODO
				break;
			case FuReadWriteClassType:
				break;
			case FuClassType:
				ReportError(expr, "Cannot modify collection through a read-only reference");
				break;
			default:
				assert false;
			}
			break;
		default:
			ReportError(expr, "Cannot modify this");
			break;
		}
	}

	FuInterpolatedString# Concatenate(FuInterpolatedString left, FuInterpolatedString right)
	{
		FuInterpolatedString# result = new FuInterpolatedString { Loc = left.Loc, Type = this.Host.Program.System.StringStorageType };
		result.Parts.AddRange(left.Parts);
		if (right.Parts.Count == 0)
			result.Suffix = left.Suffix + right.Suffix;
		else {
			result.Parts.AddRange(right.Parts);
			FuInterpolatedPart! middle = result.Parts[left.Parts.Count];
			middle.Prefix = left.Suffix + middle.Prefix;
			result.Suffix = right.Suffix;
		}
		return result;
	}

	FuInterpolatedString# ToInterpolatedString(FuExpr# expr)
	{
		if (expr is FuInterpolatedString# interpolated)
			return interpolated;
		FuInterpolatedString# result = new FuInterpolatedString { Loc = expr.Loc, Type = this.Host.Program.System.StringStorageType };
		if (expr is FuLiteral literal)
			result.Suffix = literal.GetLiteralString();
		else {
			result.AddPart("", expr);
			result.Suffix = "";
		}
		return result;
	}

	void CheckComparison(FuExpr left, FuExpr right)
	{
		if (left.Type is FuEnum)
			Coerce(right, left.Type);
		else {
			FuType doubleType = this.Host.Program.System.DoubleType;
			Coerce(left, doubleType);
			Coerce(right, doubleType);
		}
	}

	void OpenScope!(FuScope! scope)
	{
		scope.Parent = this.CurrentScope;
		this.CurrentScope = scope;
	}

	void CloseScope!()
	{
		this.CurrentScope = this.CurrentScope.Parent;
	}

	FuExpr# ResolveNew!(FuPrefixExpr# expr)
	{
		if (expr.Type != null)
			return expr;
		FuType# type;
		if (expr.Inner is FuBinaryExpr binaryNew && binaryNew.Op == FuToken.LeftBrace) {
			type = ToType(binaryNew.Left, true);
			if (!(type is FuClassType klass) || klass is FuReadWriteClassType)
				return PoisonError(expr, "Invalid argument to new");
			assert binaryNew.Right is FuAggregateInitializer# init;
			ResolveObjectLiteral(klass, init);
			expr.Type = new FuDynamicPtrType { Loc = expr.Loc, Class = klass.Class };
			expr.Inner = init;
			return expr;
		}
		type = ToType(expr.Inner, true);
		switch (type) {
		case FuArrayStorageType array:
			expr.Type = new FuDynamicPtrType { Loc = expr.Loc, Class = this.Host.Program.System.ArrayPtrClass, TypeArg0 = array.GetElementType() };
			expr.Inner = array.LengthExpr;
			return expr;
		case FuStorageType klass:
			expr.Type = new FuDynamicPtrType { Loc = expr.Loc, Class = klass.Class, TypeArg0 = klass.TypeArg0, TypeArg1 = klass.TypeArg1 };
			expr.Inner = null;
			return expr;
		default:
			return PoisonError(expr, "Invalid argument to new");
		}
	}

	FuExpr# VisitPrefixExpr!(FuPrefixExpr# expr)
	{
		FuExpr# inner;
		FuType# type;
		switch (expr.Op) {
		case FuToken.Increment:
		case FuToken.Decrement:
			inner = VisitExpr(expr.Inner);
			if (inner == this.Poison)
				return inner;
			CheckLValue(inner);
			Coerce(inner, this.Host.Program.System.DoubleType);
			if (inner.Type is FuRangeType xcrementRange) {
				int delta = expr.Op == FuToken.Increment ? 1 : -1;
				type = FuRangeType.New(xcrementRange.Min + delta, xcrementRange.Max + delta); // FIXME: overflow
			}
			else
				type = inner.Type;
			expr.Inner = inner;
			expr.Type = type;
			return expr;
		case FuToken.Minus:
			inner = VisitExpr(expr.Inner);
			if (inner == this.Poison)
				return inner;
			Coerce(inner, this.Host.Program.System.DoubleType);
			if (inner.Type is FuRangeType negRange) {
				if (negRange.Min == negRange.Max)
					return ToLiteralLong(expr, -negRange.Min);
				type = FuRangeType.New(SaturatedNeg(negRange.Max), SaturatedNeg(negRange.Min));
			}
			else if (inner is FuLiteralDouble d)
				return ToLiteralDouble(expr, -d.Value);
			else if (inner is FuLiteralLong l)
				return ToLiteralLong(expr, -l.Value);
			else
				type = inner.Type;
			break;
		case FuToken.Tilde:
			inner = VisitExpr(expr.Inner);
			if (inner == this.Poison)
				return inner;
			if (inner.Type is FuEnumFlags)
				type = inner.Type;
			else {
				Coerce(inner, this.Host.Program.System.IntType);
				if (inner.Type is FuRangeType notRange)
					type = FuRangeType.New(~notRange.Max, ~notRange.Min);
				else
					type = inner.Type;
			}
			break;
		case FuToken.ExclamationMark:
			inner = ResolveBool(expr.Inner);
			type = this.Host.Program.System.BoolType;
			break;
		case FuToken.New:
			return ResolveNew(expr);
		case FuToken.Resource:
			if (!(FoldConst(expr.Inner) is FuLiteralString# resourceName))
				return PoisonError(expr.Inner, "Resource name must be a string");
			inner = resourceName;
			type = new FuArrayStorageType { Class = this.Host.Program.System.ArrayStorageClass, TypeArg0 = this.Host.Program.System.ByteType, Length = this.Host.GetResourceLength(resourceName.Value, expr) };
			break;
		default:
			assert false;
		}
		return new FuPrefixExpr { Loc = expr.Loc, Op = expr.Op, Inner = inner, Type = type };
	}

	FuExpr# VisitPostfixExpr!(FuPostfixExpr# expr)
	{
		expr.Inner = VisitExpr(expr.Inner);
		switch (expr.Op) {
		case FuToken.Increment:
		case FuToken.Decrement:
			CheckLValue(expr.Inner);
			Coerce(expr.Inner, this.Host.Program.System.DoubleType);
			expr.Type = expr.Inner.Type;
			return expr;
		default:
			return PoisonError(expr, $"Unexpected {FuLexer.TokenToString(expr.Op)}");
		}
	}

	static bool CanCompareEqual(FuType left, FuType right)
	{
		switch (left) {
		case FuNumericType:
			return right is FuNumericType;
		case FuEnum:
			return left == right;
		case FuClassType leftClass:
			if (left.Nullable && right.Id == FuId.NullType)
				return true;
			 if ((left is FuStorageType && right is FuOwningType)
			 || (left is FuDynamicPtrType && right is FuStorageType))
				return false;
			return right is FuClassType rightClass
				&& (leftClass.Class.IsSameOrBaseOf(rightClass.Class) || rightClass.Class.IsSameOrBaseOf(leftClass.Class))
				&& leftClass.EqualTypeArguments(rightClass);
		default:
			return left.Id == FuId.NullType && right.Nullable;
		}
	}

	FuExpr# ResolveEquality(FuBinaryExpr expr, FuExpr# left, FuExpr# right)
	{
		if (!CanCompareEqual(left.Type, right.Type))
			return PoisonError(expr, $"Cannot compare '{left.Type}' with '{right.Type}'");
		if (left.Type is FuRangeType leftRange && right.Type is FuRangeType rightRange) {
			if (leftRange.Min == leftRange.Max && leftRange.Min == rightRange.Min && leftRange.Min == rightRange.Max)
				return ToLiteralBool(expr, expr.Op == FuToken.Equal);
			if (leftRange.Max < rightRange.Min || leftRange.Min > rightRange.Max)
				return ToLiteralBool(expr, expr.Op == FuToken.NotEqual);
		}
		else {
			switch (left) {
			case FuLiteralLong leftLong when right is FuLiteralLong rightLong:
				return ToLiteralBool(expr, (expr.Op == FuToken.NotEqual) ^ (leftLong.Value == rightLong.Value));
			case FuLiteralDouble leftDouble when right is FuLiteralDouble rightDouble:
				return ToLiteralBool(expr, (expr.Op == FuToken.NotEqual) ^ (leftDouble.Value == rightDouble.Value));
			case FuLiteralString leftString when right is FuLiteralString rightString:
				return ToLiteralBool(expr, (expr.Op == FuToken.NotEqual) ^ (leftString.Value == rightString.Value));
			case FuLiteralNull when right is FuLiteralNull:
			case FuLiteralFalse when right is FuLiteralFalse:
			case FuLiteralTrue when right is FuLiteralTrue:
				return ToLiteralBool(expr, expr.Op == FuToken.Equal);
			case FuLiteralFalse when right is FuLiteralTrue:
			case FuLiteralTrue when right is FuLiteralFalse:
				return ToLiteralBool(expr, expr.Op == FuToken.NotEqual);
			default:
				break;
			}
			if (left.IsConstEnum() && right.IsConstEnum())
				return ToLiteralBool(expr, (expr.Op == FuToken.NotEqual) ^ (left.IntValue() == right.IntValue()));
		}
		TakePtr(left);
		TakePtr(right);
		return new FuBinaryExpr { Loc = expr.Loc, Left = left, Op = expr.Op, Right = right, Type = this.Host.Program.System.BoolType };
	}

	void SetSharedAssign(FuExpr left, FuExpr right)
	{
		if (left.Type is FuDynamicPtrType && !right.IsUnique()) {
			left.SetShared();
			right.SetShared();
		}
	}

	void CheckIsHierarchy(FuClassType leftPtr, FuExpr left, FuClass rightClass, FuExpr expr, string op, string alwaysMessage, string neverMessage)
	{
		if (rightClass.IsSameOrBaseOf(leftPtr.Class))
			ReportError(expr, $"'{left}' is '{leftPtr.Class.Name}', '{op} {rightClass.Name}' would {alwaysMessage}");
		else if (!leftPtr.Class.IsSameOrBaseOf(rightClass))
			ReportError(expr, $"'{leftPtr.Class.Name}' is not base class of '{rightClass.Name}', '{op} {rightClass.Name}' would {neverMessage}");
	}

	void CheckIsVar(FuExpr left, FuVar def, FuExpr expr, string op, string alwaysMessage, string neverMessage)
	{
		if (!(def.Type is FuClassType! rightPtr) || rightPtr is FuStorageType)
			ReportError(def.TypeExpr, $"'{op}' with non-reference type");
		else{
			assert left.Type is FuClassType leftPtr;
			if (rightPtr is FuReadWriteClassType
			 && !(leftPtr is FuDynamicPtrType)
			 && (rightPtr is FuDynamicPtrType || !(leftPtr is FuReadWriteClassType)))
				ReportError(def.TypeExpr, $"'{leftPtr}' cannot be casted to '{rightPtr}'");
			else {
				// TODO: outside assert NotSupported(expr, "'is' operator", "c", "py", "swift", "cl");
				CheckIsHierarchy(leftPtr, left, rightPtr.Class, expr, op, alwaysMessage, neverMessage);
				if (rightPtr is FuDynamicPtrType! dynamic) {
					left.SetShared();
					dynamic.Unique = false;
				}
			}
		}
	}

	FuExpr# ResolveIs(FuBinaryExpr# expr, FuExpr# left, FuExpr right)
	{
		if (!(left.Type is FuClassType leftPtr) || left.Type is FuStorageType)
			return PoisonError(expr, "Left hand side of the 'is' operator must be an object reference");
		switch (right) {
		case FuSymbolReference symbol when symbol.Symbol is FuClass klass:
			CheckIsHierarchy(leftPtr, left, klass, expr, "is", "always equal 'true'", "always equal 'false'");
			break;
		case FuVar def:
			CheckIsVar(left, def, expr, "is", "always equal 'true'", "always equal 'false'");
			break;
		default:
			return PoisonError(expr, "Right hand side of the 'is' operator must be a class name");
		}
		expr.Left = left;
		expr.Type = this.Host.Program.System.BoolType;
		return expr;
	}

	FuExpr# VisitBinaryExpr!(FuBinaryExpr# expr)
	{
		FuExpr# left = VisitExpr(expr.Left);
		FuExpr# right = VisitExpr(expr.Right);
		if (left == this.Poison || left.Type == this.Poison || right == this.Poison || right.Type == this.Poison)
			return this.Poison;
		FuType# type;

		switch (expr.Op) {
		case FuToken.LeftBracket:
			if (!(left.Type is FuClassType klass))
				return PoisonError(expr, "Cannot index this object");
			switch (klass.Class.Id) {
			case FuId.StringClass:
				Coerce(right, this.Host.Program.System.IntType);
				if (right.Type is FuRangeType stringIndexRange && stringIndexRange.Max < 0)
					ReportError(right, "Negative index");
				else if (left is FuLiteralString stringLiteral && right is FuLiteralLong indexLiteral) {
					long i = indexLiteral.Value;
					if (i >= 0 && i <= int.MaxValue) {
						int c = stringLiteral.GetAsciiAt(i);
						if (c >= 0)
							return FuLiteralChar.New(c, expr.Loc);
					}
				}
				type = this.Host.Program.System.CharType;
				break;
			case FuId.ArrayPtrClass:
			case FuId.ArrayStorageClass:
			case FuId.ListClass:
				Coerce(right, this.Host.Program.System.IntType);
				if (right.Type is FuRangeType indexRange) {
					if (indexRange.Max < 0)
						ReportError(right, "Negative index");
					else if (klass is FuArrayStorageType array && indexRange.Min >= array.Length)
						ReportError(right, "Array index out of bounds");
				}
				type = klass.GetElementType();
				break;
			case FuId.DictionaryClass:
			case FuId.SortedDictionaryClass:
			case FuId.OrderedDictionaryClass:
				Coerce(right, klass.GetKeyType());
				type = klass.GetValueType();
				break;
			default:
				return PoisonError(expr, "Cannot index this object");
			}
			break;

		case FuToken.Plus:
			if (left.Type is FuRangeType leftAdd && right.Type is FuRangeType rightAdd) {
				type = FuRangeType.New(
					SaturatedAdd(leftAdd.Min, rightAdd.Min),
					SaturatedAdd(leftAdd.Max, rightAdd.Max));
			}
			else if (left.Type is FuStringType) {
				Coerce(right, this.Host.Program.System.StringPtrType);
				if (left is FuLiteral leftLiteral && right is FuLiteral rightLiteral)
					return this.Host.Program.System.NewLiteralString(leftLiteral.GetLiteralString() + rightLiteral.GetLiteralString(), expr.Loc);
				if (left is FuInterpolatedString || right is FuInterpolatedString)
					return Concatenate(ToInterpolatedString(left), ToInterpolatedString(right));
				type = this.Host.Program.System.StringStorageType;
			}
			else
				type = GetNumericType(left, right);
			break;
		case FuToken.Minus:
			if (left.Type is FuRangeType leftSub && right.Type is FuRangeType rightSub) {
				type = FuRangeType.New(
					SaturatedSub(leftSub.Min, rightSub.Max),
					SaturatedSub(leftSub.Max, rightSub.Min));
			}
			else
				type = GetNumericType(left, right);
			break;
		case FuToken.Asterisk:
			if (left.Type is FuRangeType leftMul && right.Type is FuRangeType rightMul) {
				type = NewRangeType(
					SaturatedMul(leftMul.Min, rightMul.Min),
					SaturatedMul(leftMul.Min, rightMul.Max),
					SaturatedMul(leftMul.Max, rightMul.Min),
					SaturatedMul(leftMul.Max, rightMul.Max));
			}
			else
				type = GetNumericType(left, right);
			break;
		case FuToken.Slash:
			if (left.Type is FuRangeType leftDiv && right.Type is FuRangeType rightDiv) {
				int denMin = rightDiv.Min;
				if (denMin == 0)
					denMin = 1;
				int denMax = rightDiv.Max;
				if (denMax == 0)
					denMax = -1;
				type = NewRangeType(
					SaturatedDiv(leftDiv.Min, denMin),
					SaturatedDiv(leftDiv.Min, denMax),
					SaturatedDiv(leftDiv.Max, denMin),
					SaturatedDiv(leftDiv.Max, denMax));
			}
			else
				type = GetNumericType(left, right);
			break;
		case FuToken.Mod:
			if (left.Type is FuRangeType leftMod && right.Type is FuRangeType rightMod) {
				int den = ~Math.Min(rightMod.Min, -rightMod.Max); // max(abs(rightRange))-1
				if (den < 0)
					return PoisonError(expr, "Mod zero");
				type = FuRangeType.New(
					leftMod.Min >= 0 ? 0 : Math.Max(leftMod.Min, -den),
					leftMod.Max < 0 ? 0 : Math.Min(leftMod.Max, den));
			}
			else
				type = GetIntegerType(left, right);
			break;

		case FuToken.And:
		case FuToken.Or:
		case FuToken.Xor:
			type = BitwiseOp(left, expr.Op, right);
			break;

		case FuToken.ShiftLeft:
			if (left.Type is FuRangeType leftShl && right.Type is FuRangeType rightShl && leftShl.Min == leftShl.Max && rightShl.Min == rightShl.Max) {
				// TODO: improve
				int result = leftShl.Min << rightShl.Min;
				type = FuRangeType.New(result, result);
			}
			else
				type = GetShiftType(left, right);
			break;
		case FuToken.ShiftRight:
			if (left.Type is FuRangeType leftShr && right.Type is FuRangeType rightShr) {
				if (rightShr.Min < 0)
					rightShr = FuRangeType.New(0, 32);
				type = FuRangeType.New(
					SaturatedShiftRight(leftShr.Min, leftShr.Min < 0 ? rightShr.Min : rightShr.Max),
					SaturatedShiftRight(leftShr.Max, leftShr.Max < 0 ? rightShr.Max : rightShr.Min));
			}
			else
				type = GetShiftType(left, right);
			break;

		case FuToken.Equal:
		case FuToken.NotEqual:
			return ResolveEquality(expr, left, right);
		case FuToken.Less:
			if (left.Type is FuRangeType leftLess && right.Type is FuRangeType rightLess) {
				if (leftLess.Max < rightLess.Min)
					return ToLiteralBool(expr, true);
				if (leftLess.Min >= rightLess.Max)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Host.Program.System.BoolType;
			break;
		case FuToken.LessOrEqual:
			if (left.Type is FuRangeType leftLeq && right.Type is FuRangeType rightLeq) {
				if (leftLeq.Max <= rightLeq.Min)
					return ToLiteralBool(expr, true);
				if (leftLeq.Min > rightLeq.Max)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Host.Program.System.BoolType;
			break;
		case FuToken.Greater:
			if (left.Type is FuRangeType leftGreater && right.Type is FuRangeType rightGreater) {
				if (leftGreater.Min > rightGreater.Max)
					return ToLiteralBool(expr, true);
				if (leftGreater.Max <= rightGreater.Min)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Host.Program.System.BoolType;
			break;
		case FuToken.GreaterOrEqual:
			if (left.Type is FuRangeType leftGeq && right.Type is FuRangeType rightGeq) {
				if (leftGeq.Min >= rightGeq.Max)
					return ToLiteralBool(expr, true);
				if (leftGeq.Max < rightGeq.Min)
					return ToLiteralBool(expr, false);
			}
			else
				CheckComparison(left, right);
			type = this.Host.Program.System.BoolType;
			break;

		case FuToken.CondAnd:
			Coerce(left, this.Host.Program.System.BoolType);
			Coerce(right, this.Host.Program.System.BoolType);
			if (left is FuLiteralTrue)
				return right;
			if (left is FuLiteralFalse || right is FuLiteralTrue)
				return left;
			type = this.Host.Program.System.BoolType;
			break;
		case FuToken.CondOr:
			Coerce(left, this.Host.Program.System.BoolType);
			Coerce(right, this.Host.Program.System.BoolType);
			if (left is FuLiteralTrue || right is FuLiteralFalse)
				return left;
			if (left is FuLiteralFalse)
				return right;
			type = this.Host.Program.System.BoolType;
			break;

		case FuToken.Assign:
			CheckLValue(left);
			CoercePermanent(right, left.Type);
			if (left.Type is FuStorageType && right is FuSymbolReference
				&& !(left is FuSymbolReference symbol && symbol.Symbol is FuNamedValue storageDef && storageDef.IsAssignableStorage()))
				ReportError(right, "Cannot copy object storage");
			SetSharedAssign(left, right);
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case FuToken.AddAssign:
			CheckLValue(left);
			if (left.Type.Id == FuId.StringStorageType)
				Coerce(right, this.Host.Program.System.StringPtrType);
			else {
				Coerce(left, this.Host.Program.System.DoubleType);
				Coerce(right, left.Type);
			}
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case FuToken.SubAssign:
		case FuToken.MulAssign:
		case FuToken.DivAssign:
			CheckLValue(left);
			Coerce(left, this.Host.Program.System.DoubleType);
			Coerce(right, left.Type);
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case FuToken.ModAssign:
		case FuToken.ShiftLeftAssign:
		case FuToken.ShiftRightAssign:
			CheckLValue(left);
			Coerce(left, this.Host.Program.System.IntType);
			Coerce(right, this.Host.Program.System.IntType);
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case FuToken.AndAssign:
		case FuToken.OrAssign:
		case FuToken.XorAssign:
			CheckLValue(left);
			if (!IsEnumOp(left, right)) {
				Coerce(left, this.Host.Program.System.IntType);
				Coerce(right, this.Host.Program.System.IntType);
			}
			expr.Left = left;
			expr.Right = right;
			expr.Type = left.Type;
			return expr;

		case FuToken.Is:
			return ResolveIs(expr, left, right);

		case FuToken.Range:
			return PoisonError(expr, "Range within an expression");
		default:
			assert false;
		}
		if (type is FuRangeType range && range.Min == range.Max)
			return ToLiteralLong(expr, range.Min);
		return new FuBinaryExpr { Loc = expr.Loc, Left = left, Op = expr.Op, Right = right, Type = type };
	}

	FuType# TryGetPtr(FuType# type, bool nullable)
	{
		if (type.Id == FuId.StringStorageType)
			return nullable ? this.Host.Program.System.StringNullablePtrType : this.Host.Program.System.StringPtrType;
		if (type is FuStorageType storage)
			return new FuReadWriteClassType { Class = storage.Class.Id == FuId.ArrayStorageClass ? this.Host.Program.System.ArrayPtrClass : storage.Class, Nullable = nullable,
				TypeArg0 = storage.TypeArg0, TypeArg1 = storage.TypeArg1 };
		if (nullable && type is FuClassType ptr && !ptr.Nullable) {
			FuClassType# result;
			if (type is FuDynamicPtrType)
				result = new FuDynamicPtrType();
			else if (type is FuReadWriteClassType)
				result = new FuReadWriteClassType();
			else
				result = new FuClassType();
			result.Class = ptr.Class;
			result.Nullable = true;
			result.TypeArg0 = ptr.TypeArg0;
			result.TypeArg1 = ptr.TypeArg1;
			return result;
		}
		return type;
	}

	static FuClass? GetLowestCommonAncestor(FuClass left, FuClass right)
	{
		for (;;) {
			if (left.IsSameOrBaseOf(right))
				return left;
			if (left.Parent is FuClass parent)
				left = parent;
			else
				return null;
		}
	}

	FuType# GetCommonType(FuExpr left, FuExpr right)
	{
		if (left.Type is FuRangeType# leftRange && right.Type is FuRangeType# rightRange)
			return Union(leftRange, rightRange);
		bool nullable = left.Type.Nullable || right.Type.Nullable;
		FuType# ptr = TryGetPtr(left.Type, nullable);
		if (ptr.IsAssignableFrom(right.Type))
			return ptr;
		ptr = TryGetPtr(right.Type, nullable);
		if (ptr.IsAssignableFrom(left.Type))
			return ptr;
		if (left.Type is FuClassType leftClass && right.Type is FuClassType rightClass && leftClass.EqualTypeArguments(rightClass)) {
			FuClass? klass = GetLowestCommonAncestor(leftClass.Class, rightClass.Class);
			if (klass != null) {
				FuClassType# result;
				if (!(leftClass is FuReadWriteClassType) || !(rightClass is FuReadWriteClassType))
					result = new FuClassType();
				else if (leftClass is FuDynamicPtrType && rightClass is FuDynamicPtrType)
					result = new FuDynamicPtrType();
				else
					result = new FuReadWriteClassType();
				result.Class = klass;
				result.Nullable = nullable;
				result.TypeArg0 = leftClass.TypeArg0;
				result.TypeArg1 = leftClass.TypeArg1;
				return result;
			}
		}
		return PoisonError(left, $"Incompatible types: '{left.Type}' and '{right.Type}'");
	}

	FuExpr# VisitSelectExpr!(FuSelectExpr expr)
	{
		FuExpr# cond = ResolveBool(expr.Cond);
		FuExpr# onTrue = VisitExpr(expr.OnTrue);
		FuExpr# onFalse = VisitExpr(expr.OnFalse);
		if (onTrue == this.Poison || onTrue.Type == this.Poison || onFalse == this.Poison || onFalse.Type == this.Poison)
			return this.Poison;
		FuType# type = GetCommonType(onTrue, onFalse);
		Coerce(onTrue, type);
		Coerce(onFalse, type);
		if (cond is FuLiteralTrue)
			return onTrue;
		if (cond is FuLiteralFalse)
			return onFalse;
		return new FuSelectExpr { Loc = expr.Loc, Cond = cond, OnTrue = onTrue, OnFalse = onFalse, Type = type };
	}

	FuType# EvalType(FuClassType generic, FuType# type)
	{
		if (type.Id == FuId.TypeParam0)
			return generic.TypeArg0;
		if (type.Id == FuId.TypeParam0NotFinal)
			return generic.TypeArg0.IsFinal() ? null : generic.TypeArg0;
		if (type is FuClassType collection && collection.Class.TypeParameterCount == 1 && collection.TypeArg0.Id == FuId.TypeParam0) {
			FuClassType# result = type is FuReadWriteClassType ? new FuReadWriteClassType() : new FuClassType();
			result.Class = collection.Class;
			result.TypeArg0 = generic.TypeArg0;
			return result;
		}
		return type;
	}

	bool CanCall(FuExpr? obj, FuMethod method, List<FuExpr#> arguments)
	{
		FuVar? param = method.FirstParameter();
		foreach (FuExpr arg in arguments) {
			if (param == null)
				return false;
			FuType# type = param.Type;
			if (obj != null && obj.Type is FuClassType generic)
				type = EvalType(generic, type);
			if (!type.IsAssignableFrom(arg.Type))
				return false;
			param = param.NextVar();
		}
		return param == null || param.Value != null;
	}

	static bool MethodHasThrows(FuMethodBase method, FuClass exception)
		=> method.Throws.Any(symbol => symbol.Symbol is FuClass klass && klass.IsSameOrBaseOf(exception));

	FuExpr# ResolveCallWithArguments!(FuCallExpr# expr, List<FuExpr#> arguments)
	{
		if (!(VisitExpr(expr.Method) is FuSymbolReference# symbol))
			return this.Poison;
		FuMethod! method;
		switch (symbol.Symbol) {
		case null:
			return this.Poison;
		case FuMethod! m:
			method = m;
			break;
		case FuMethodGroup group:
			method = group.Methods[0];
			if (!CanCall(symbol.Left, method, arguments))
				method = group.Methods[1];
			break;
		default:
			return PoisonError(symbol, "Expected a method");
		}

		if (!method.IsStatic() && method.IsMutator()) {
			if (symbol.Left == null) {
				if (!this.CurrentMethod.IsMutator())
					ReportError(expr.Method, $"Cannot call mutating method '{method.Name}' from a non-mutating method");
			}
			else if (symbol.Left is FuSymbolReference baseRef && baseRef.Symbol.Id == FuId.BasePtr) {
			}
			else if (!(symbol.Left.Type is FuReadWriteClassType)) {
				switch (method.Id) {
				case FuId.IntTryParse:
				case FuId.LongTryParse:
				case FuId.DoubleTryParse:
					if (symbol.Left is FuSymbolReference varRef && varRef.Symbol is FuVar! def)
						def.IsAssigned = true;
					break;
				default:
					ReportError(symbol.Left, $"Cannot call mutating method '{method.Name}' on a read-only reference");
					break;
				}
			}
		}
		int i = 0;
		for (FuVar? param = method.FirstParameter(); param != null; param = param.NextVar()) {
			FuType#? type = param.Type;
			if (symbol.Left != null && symbol.Left.Type is FuClassType generic) {
				type = EvalType(generic, type);
				if (type == null)
					continue;
			}
			if (i >= arguments.Count) {
				if (param.Value != null)
					break;
				return PoisonError(expr, $"Too few arguments for '{method.Name}'");
			}
			FuExpr! arg = arguments[i++];
			if (type.Id == FuId.TypeParam0Predicate && arg is FuLambdaExpr! lambda) {
				lambda.First.Type = symbol.Left.Type.AsClassType().TypeArg0;
				OpenScope(lambda);
				lambda.Body = VisitExpr(lambda.Body);
				CloseScope();
				Coerce(lambda.Body, this.Host.Program.System.BoolType);
				Coerce(lambda.Body, this.Host.Program.System.BoolType);
			}
			else {
				Coerce(arg, type);
				if (type is FuDynamicPtrType)
					arg.SetShared();
			}
		}
		if (i < arguments.Count)
			return PoisonError(arguments[i], $"Too many arguments for '{method.Name}'");

		foreach (FuSymbolReference exceptionDecl in method.Throws) {
			if (this.CurrentMethod == null) {
				ReportError(expr.Method, $"Cannot call method '{method.Name}' here because it is marked 'throws'");
				break;
			}
			if (exceptionDecl.Symbol is FuClass exception && !MethodHasThrows(this.CurrentMethod, exception))
				ReportError(expr.Method, $"Method marked 'throws {exception.Name}' called from a method without it");
		}

		symbol.Symbol = method;

		if (method.IsStatic()
		 && method.Body is FuReturn! ret
		 && arguments.All(arg => arg is FuLiteral)
		 && !this.CurrentPureMethods.Contains(method)) {
			this.CurrentPureMethods.Add(method);
			i = 0;
			for (FuVar? param = method.FirstParameter(); param != null; param = param.NextVar()) {
				if (i < arguments.Count)
					this.CurrentPureArguments[param] = arguments[i++];
				else
					this.CurrentPureArguments[param] = param.Value;
			}
			FuScope! callSite = this.CurrentScope;
			ret.Parent = method.Parameters;
			this.CurrentScope = ret;
			FuExpr# result = VisitExpr(ret.Value);
			this.CurrentScope = callSite;
			for (FuVar? param = method.FirstParameter(); param != null; param = param.NextVar())
				this.CurrentPureArguments.Remove(param);
			this.CurrentPureMethods.Remove(method);
			if (result is FuLiteral)
				return result;
		}

		if (this.CurrentMethod != null)
			this.CurrentMethod.Calls.Add(method);
		if (this.CurrentPureArguments.Count == 0) {
			expr.Method = symbol;
			FuType# type = method.Type;
			if (symbol.Left != null && symbol.Left.Type is FuClassType generic)
				type = EvalType(generic, type);
			else if (arguments.Any(arg => arg.Type == null)) {
				// an error - prevent null dereferences
			}
			else if (type.Id == FuId.FloatingType)
				type = arguments.Any(arg => arg.Type.Id == FuId.DoubleType) ? this.Host.Program.System.DoubleType : this.Host.Program.System.FloatType;
			else if (type.Id == FuId.NumericType) {
				type = arguments.Any(arg => arg.Type.Id == FuId.DoubleType) ? this.Host.Program.System.DoubleType
					: arguments.Any(arg => arg.Type.Id == FuId.FloatType) ? this.Host.Program.System.FloatType
					: arguments.Any(arg => arg.Type.Id == FuId.LongType) ? this.Host.Program.System.LongType
					: this.Host.Program.System.IntType;
			}
			expr.Type = type;
		}
		return expr;
	}

	FuExpr# VisitCallExpr!(FuCallExpr# expr)
	{
		if (this.CurrentPureArguments.Count == 0) {
			List<FuExpr#>! arguments = expr.Arguments;
			for (int i = 0; i < arguments.Count; i++) {
				if (!(arguments[i] is FuLambdaExpr))
					arguments[i] = VisitExpr(arguments[i]);
			}
			return ResolveCallWithArguments(expr, arguments);
		}
		else {
			List<FuExpr#>() arguments;
			foreach (FuExpr# arg in expr.Arguments)
				arguments.Add(VisitExpr(arg));
			return ResolveCallWithArguments(expr, arguments);
		}
	}

	void ResolveObjectLiteral!(FuClassType klass, FuAggregateInitializer init)
	{
		foreach (FuExpr! item in init.Items) {
			assert item is FuBinaryExpr! field;
			assert field.Op == FuToken.Assign;
			assert field.Left is FuSymbolReference# symbol;
			Lookup(symbol, klass.Class);
			if (symbol.Symbol is FuField) {
				field.Right = VisitExpr(field.Right);
				Coerce(field.Right, symbol.Type);
				SetSharedAssign(field.Left, field.Right);
			}
			else
				ReportError(field.Left, "Expected a field");
		}
	}

	static void InitUnique(FuNamedValue varOrField)
	{
		if (varOrField.Type is FuDynamicPtrType! dynamic) {
			if (varOrField.Value == null || varOrField.Value.IsUnique())
				dynamic.Unique = true;
			else
				varOrField.Value.SetShared();
		}
	}

	void VisitVar!(FuVar# expr)
	{
		FuType type = ResolveType(expr);
		if (expr.Value != null) {
			if (type is FuStorageType storage && expr.Value is FuAggregateInitializer init)
				ResolveObjectLiteral(storage, init);
			else {
				expr.Value = VisitExpr(expr.Value);
				if (!expr.IsAssignableStorage()) {
					if (type is FuArrayStorageType array) {
						type = array.GetElementType();
						if (!(expr.Value is FuLiteral literal) || !literal.IsDefaultValue())
							ReportError(expr.Value, "Only null, zero and false supported as an array initializer");
					}
					else if (type is FuStorageType && expr.Value is FuSymbolReference)
						ReportError(expr.Value, "Cannot copy object storage");
					CoercePermanent(expr.Value, type);
				}
			}
		}
		InitUnique(expr);
		this.CurrentScope.Add(expr);
	}

	FuExpr# VisitExpr!(FuExpr# expr)
	{
		switch (expr) {
		case FuAggregateInitializer! aggregate:
			List<FuExpr#>! items = aggregate.Items;
			for (int i = 0; i < items.Count; i++)
				items[i] = VisitExpr(items[i]);
			return expr;
		case FuLiteral:
			return expr;
		case FuInterpolatedString# interpolated:
			return VisitInterpolatedString(interpolated);
		case FuSymbolReference# symbol:
			return VisitSymbolReference(symbol);
		case FuPrefixExpr# prefix:
			return VisitPrefixExpr(prefix);
		case FuPostfixExpr# postfix:
			return VisitPostfixExpr(postfix);
		case FuBinaryExpr# binary:
			return VisitBinaryExpr(binary);
		case FuSelectExpr select:
			return VisitSelectExpr(select);
		case FuCallExpr# call:
			return VisitCallExpr(call);
		case FuLambdaExpr:
			ReportError(expr, "Unexpected lambda expression");
			return expr;
		case FuVar# def:
			VisitVar(def);
			return expr;
		default:
			if (expr == this.Poison)
				return expr;
			assert false;
		}
	}

	FuExpr# ResolveBool!(FuExpr# expr)
	{
		expr = VisitExpr(expr);
		Coerce(expr, this.Host.Program.System.BoolType);
		return expr;
	}

	static FuClassType# CreateClassPtr(FuClass klass, FuToken ptrModifier, bool nullable)
	{
		FuClassType# ptr;
		switch (ptrModifier) {
		case FuToken.EndOfFile:
			ptr = new FuClassType();
			break;
		case FuToken.ExclamationMark:
			ptr = new FuReadWriteClassType();
			break;
		case FuToken.Hash:
			ptr = new FuDynamicPtrType();
			break;
		default:
			assert false;
		}
		ptr.Class = klass;
		ptr.Nullable = nullable;
		return ptr;
	}

	void FillGenericClass!(FuClassType! result, FuClass klass, FuAggregateInitializer typeArgExprs)
	{
		List<FuType#>() typeArgs;
		foreach (FuExpr# typeArgExpr in typeArgExprs.Items)
			typeArgs.Add(ToType(typeArgExpr, false));
		if (typeArgs.Count != klass.TypeParameterCount) {
			ReportError(typeArgExprs, $"Expected {klass.TypeParameterCount} type arguments for '{klass.Name}', got {typeArgs.Count}");
			return;
		}
		result.Class = klass;
		result.TypeArg0 = typeArgs[0];
		if (typeArgs.Count == 2)
			result.TypeArg1 = typeArgs[1];
	}

	bool ExpectNoPtrModifier(FuExpr expr, FuToken ptrModifier, bool nullable)
	{
		if (ptrModifier != FuToken.EndOfFile)
			ReportError(expr, $"Unexpected {FuLexer.TokenToString(ptrModifier)} on a non-reference type");
		if (nullable) {
			ReportError(expr, "Nullable value types not supported");
			return false;
		}
		return ptrModifier == FuToken.EndOfFile;
	}

	FuType# ToBaseType!(FuExpr! expr, FuToken ptrModifier, bool nullable)
	{
		switch (expr) {
		case FuSymbolReference! symbol:
			// built-in, string?, MyEnum, MyClass, MyClass?, MyClass!, MyClass!?, MyClass#, MyClass#?
			if (this.Host.Program.TryLookup(symbol.Name, true) is FuType# type) {
				symbol.Symbol = type; // for vscode goto
				if (type is FuClass klass) {
					if (klass.Id == FuId.MatchClass && ptrModifier != FuToken.EndOfFile)
						ReportError(expr, "Read-write references to the built-in class Match are not supported");
					FuClassType# ptr = CreateClassPtr(klass, ptrModifier, nullable);
					if (symbol.Left is FuAggregateInitializer typeArgExprs)
						FillGenericClass(ptr, klass, typeArgExprs);
					else if (symbol.Left != null)
						return PoisonError(expr, "Invalid type");
					else
						ptr.Name = klass.Name; // TODO: needed?
					return ptr;
				}
				else if (symbol.Left != null)
					return PoisonError(expr, "Invalid type");
				if (type.Id == FuId.StringPtrType && nullable) {
					type = this.Host.Program.System.StringNullablePtrType;
					nullable = false;
				}
				return ExpectNoPtrModifier(expr, ptrModifier, nullable) ? type : this.Poison;
			}
			return PoisonError(expr, $"Type '{symbol.Name}' not found");

		case FuCallExpr call:
			// string(), MyClass()
			if (!ExpectNoPtrModifier(expr, ptrModifier, nullable))
				return this.Poison;
			if (call.Arguments.Count != 0)
				return PoisonError(call, "Expected empty parentheses for storage type");
			if (call.Method.Left is FuAggregateInitializer typeArgExprs2) {
				if (this.Host.Program.TryLookup(call.Method.Name, true) is FuClass klass) {
					FuStorageType# storage = new FuStorageType();
					FillGenericClass(storage, klass, typeArgExprs2);
					return storage;
				}
				return PoisonError(typeArgExprs2, $"'{call.Method.Name}' is not a class");
			}
			else if (call.Method.Left != null)
				return PoisonError(expr, "Invalid type");
			if (call.Method.Name == "string")
				return this.Host.Program.System.StringStorageType;
			if (this.Host.Program.TryLookup(call.Method.Name, true) is FuClass! klass2) {
				call.Method.Symbol = klass2; // for vscode goto
				return new FuStorageType { Class = klass2 };
			}
			return PoisonError(expr, $"Class '{call.Method.Name}' not found");

		default:
			return PoisonError(expr, "Invalid type");
		}
	}

	FuType# ToType!(FuExpr# expr, bool dynamic)
	{
		FuExpr#? minExpr = null;
		if (expr is FuBinaryExpr range && range.Op == FuToken.Range) {
			minExpr = range.Left;
			expr = range.Right;
		}

		bool nullable;
		FuToken ptrModifier;
		FuClassType#? outerArray = null; // leftmost in source
		FuClassType!? innerArray = null; // rightmost in source
		for (;;) {
			if (expr is FuPostfixExpr question && question.Op == FuToken.QuestionMark) {
				expr = question.Inner;
				nullable = true;
			}
			else
				nullable = false;
			if (expr is FuPostfixExpr postfix && (postfix.Op == FuToken.ExclamationMark || postfix.Op == FuToken.Hash)) {
				expr = postfix.Inner;
				ptrModifier = postfix.Op;
			}
			else
				ptrModifier = FuToken.EndOfFile;
			if (expr is FuBinaryExpr binary && binary.Op == FuToken.LeftBracket) {
				if (binary.Right != null) {
					if (!ExpectNoPtrModifier(expr, ptrModifier, nullable))
						return this.Poison;
					FuExpr# lengthExpr = VisitExpr(binary.Right);
					FuArrayStorageType# arrayStorage = new FuArrayStorageType { Class = this.Host.Program.System.ArrayStorageClass, TypeArg0 = outerArray, LengthExpr = lengthExpr, Length = 0 };
					if (Coerce(lengthExpr, this.Host.Program.System.IntType) && (!dynamic || binary.Left.IsIndexing())) {
						if (lengthExpr is FuLiteralLong literal) {
							long length = literal.Value;
							if (length < 0)
								ReportError(expr, "Expected non-negative integer");
							else if (length > int.MaxValue)
								ReportError(expr, "Integer too big");
							else
								arrayStorage.Length = length;
						}
						else
							ReportError(lengthExpr, "Expected constant value");
					}
					outerArray = arrayStorage;
				}
				else {
					FuType# elementType = outerArray;
					outerArray = CreateClassPtr(this.Host.Program.System.ArrayPtrClass, ptrModifier, nullable);
					outerArray.TypeArg0 = elementType;
				}
				if (innerArray == null)
					innerArray = outerArray;
				expr = binary.Left;
			}
			else
				break;
		}

		FuType# baseType;
		if (minExpr != null) {
			if (!ExpectNoPtrModifier(expr, ptrModifier, nullable))
				return this.Poison;
			int min = FoldConstInt(minExpr);
			int max = FoldConstInt(expr);
			if (min > max)
				return PoisonError(expr, "Range min greater than max");
			baseType = FuRangeType.New(min, max);
		}
		else
			baseType = ToBaseType(expr, ptrModifier, nullable);

		if (outerArray == null)
			return baseType;
		innerArray.TypeArg0 = baseType;
		return outerArray;
	}

	FuType# ResolveType!(FuNamedValue! def)
	{
		def.Type = ToType(def.TypeExpr, false);
		return def.Type;
	}

	void VisitAssert!(FuAssert! statement)
	{
		statement.Cond = ResolveBool(statement.Cond);
		if (statement.Message != null) {
			statement.Message = VisitExpr(statement.Message);
			if (!(statement.Message.Type is FuStringType))
				ReportError(statement.Message, "The second argument of 'assert' must be a string");
		}
	}

	bool ResolveStatements!(List<FuStatement#> statements)
	{
		bool reachable = true;
		foreach (FuStatement# statement in statements) {
			if (statement is FuConst# konst) {
				ResolveConst(konst);
				this.CurrentScope.Add(konst);
				if (konst.Type is FuArrayStorageType) {
					assert GetCurrentContainer() is FuClass! klass;
					FuConst!? last = null;
					foreach (FuConst! previous in klass.ConstArrays) {
						if (previous.Name == konst.Name && previous.InMethod == konst.InMethod)
							last = previous;
					}
					if (last != null) {
						if (last.InMethodIndex == 0)
							last.InMethodIndex = 1;
						konst.InMethodIndex = last.InMethodIndex + 1;
					}
					klass.ConstArrays.Add(konst);
				}
			}
			else
				VisitStatement(statement);
			if (!reachable) {
				ReportError(statement, "Unreachable statement");
				return false;
			}
			reachable = statement.CompletesNormally();
		}
		return reachable;
	}

	void CheckInitialized!(FuVar def)
	{
		if (def.Type == this.Poison || def.IsAssigned)
			return;
		if (def.Type is FuStorageType
				? !(def.Type is FuArrayStorageType) && def.Value is FuLiteralNull
				: def.Value == null)
			ReportError(def, "Uninitialized variable");
	}

	void VisitBlock!(FuBlock! statement)
	{
		OpenScope(statement);
		statement.SetCompletesNormally(ResolveStatements(statement.Statements));
		for (FuSymbol? symbol = statement.First; symbol != null; symbol = symbol.Next) {
			if (symbol is FuVar def)
				CheckInitialized(def);
		}
		CloseScope();
	}

	void ResolveLoopCond!(FuLoop! statement)
	{
		if (statement.Cond != null) {
			statement.Cond = ResolveBool(statement.Cond);
			statement.SetCompletesNormally(!(statement.Cond is FuLiteralTrue));
		}
		else
			statement.SetCompletesNormally(false);
	}

	void VisitDoWhile!(FuDoWhile! statement)
	{
		OpenScope(statement);
		ResolveLoopCond(statement);
		VisitStatement(statement.Body);
		CloseScope();
	}

	void VisitFor!(FuFor! statement)
	{
		OpenScope(statement);
		if (statement.Init != null)
			VisitStatement(statement.Init);
		ResolveLoopCond(statement);
		if (statement.Advance != null)
			VisitStatement(statement.Advance);
		if (statement.Init is FuVar indVar
			&& indVar.Type is FuIntegerType
			&& indVar.Value != null
			&& statement.Cond is FuBinaryExpr cond
			&& cond.Left.IsReferenceTo(indVar)
			&& (cond.Right is FuLiteral || (cond.Right is FuSymbolReference limitSymbol && limitSymbol.Symbol is FuVar))
			&& statement.Advance != null) {
			long step = 0;
			switch (statement.Advance) {
			case FuUnaryExpr unary when unary.Inner != null && unary.Inner.IsReferenceTo(indVar):
				switch (unary.Op) {
				case FuToken.Increment:
					step = 1;
					break;
				case FuToken.Decrement:
					step = -1;
					break;
				default:
					break;
				}
				break;
			case FuBinaryExpr binary when binary.Left.IsReferenceTo(indVar) && binary.Right is FuLiteralLong literalStep:
				switch (binary.Op) {
				case FuToken.AddAssign:
					step = literalStep.Value;
					break;
				case FuToken.SubAssign:
					step = -literalStep.Value;
					break;
				default:
					break;
				}
				break;
			default:
				break;
			}
			if ((step > 0 && (cond.Op == FuToken.Less || cond.Op == FuToken.LessOrEqual))
			 || (step < 0 && (cond.Op == FuToken.Greater || cond.Op == FuToken.GreaterOrEqual))) {
				statement.IsRange = true;
				statement.RangeStep = step;
				statement.IsIndVarUsed = false;
			}
		}
		VisitStatement(statement.Body);
		if (statement.Init is FuVar initVar)
			CheckInitialized(initVar);
		CloseScope();
	}

	void VisitForeach!(FuForeach! statement)
	{
		OpenScope(statement);
		FuVar! element = statement.GetVar();
		ResolveType(element);
		if (VisitExpr(statement.Collection) != this.Poison) {
			if (statement.Collection.Type is FuClassType klass) {
				switch (klass.Class.Id) {
				case FuId.StringClass:
					if (statement.Count() != 1 || !element.Type.IsAssignableFrom(this.Host.Program.System.IntType))
						ReportError(element.TypeExpr, "Expected 'int' iterator variable");
					break;
				case FuId.ArrayStorageClass:
				case FuId.ListClass:
				case FuId.HashSetClass:
				case FuId.SortedSetClass:
					if (statement.Count() != 1)
						ReportError(statement.GetValueVar(), "Expected one iterator variable");
					else if (!element.Type.IsAssignableFrom(klass.GetElementType()))
						ReportError(element.TypeExpr, $"Cannot convert '{klass.GetElementType()}' to '{element.Type}'");
					break;
				case FuId.DictionaryClass:
				case FuId.SortedDictionaryClass:
				case FuId.OrderedDictionaryClass:
					if (statement.Count() != 2)
						ReportError(element, "Expected '(TKey key, TValue value)' iterator");
					else {
						FuVar! value = statement.GetValueVar();
						ResolveType(value);
						if (!element.Type.IsAssignableFrom(klass.GetKeyType()))
							ReportError(element, $"Cannot convert '{klass.GetKeyType()}' to '{element.Type}'");
						if (!value.Type.IsAssignableFrom(klass.GetValueType()))
							ReportError(value, $"Cannot convert '{klass.GetValueType()}' to '{value.Type}'");
					}
					break;
				default:
					ReportError(statement.Collection, $"'foreach' invalid on '{klass.Class.Name}'");
					break;
				}
			}
			else
				ReportError(statement.Collection, $"'foreach' invalid on '{statement.Collection.Type}'");
		}
		statement.SetCompletesNormally(true);
		VisitStatement(statement.Body);
		CloseScope();
	}

	void VisitIf!(FuIf! statement)
	{
		statement.Cond = ResolveBool(statement.Cond);
		VisitStatement(statement.OnTrue);
		if (statement.OnFalse != null) {
			VisitStatement(statement.OnFalse);
			statement.SetCompletesNormally(statement.OnTrue.CompletesNormally() || statement.OnFalse.CompletesNormally());
		}
		else
			statement.SetCompletesNormally(true);
	}

	void VisitLock!(FuLock! statement)
	{
		statement.Lock = VisitExpr(statement.Lock);
		Coerce(statement.Lock, this.Host.Program.System.LockPtrType);
		VisitStatement(statement.Body);
	}

	void VisitReturn!(FuReturn! statement)
	{
		if (this.CurrentMethod.Type.Id == FuId.VoidType) {
			if (statement.Value != null)
				ReportError(statement.Value, "Void method cannot return a value");
		}
		else if (statement.Value == null)
			ReportError(statement, "Missing return value");
		else {
			OpenScope(statement);
			statement.Value = VisitExpr(statement.Value);
			CoercePermanent(statement.Value, this.CurrentMethod.Type);
			if (this.CurrentMethod.Type is FuDynamicPtrType)
				statement.Value.SetShared();
			if (statement.Value is FuSymbolReference symbol
			 && symbol.Symbol is FuVar local
			 && ((local.Type.IsFinal() && !(this.CurrentMethod.Type is FuStorageType))
				|| (local.Type.Id == FuId.StringStorageType && this.CurrentMethod.Type.Id != FuId.StringStorageType)))
				ReportError(symbol, "Returning dangling reference to local storage");
			CloseScope();
		}
	}

	void ResolveCaseType!(FuSwitch! statement, FuClassType switchPtr, FuExpr# value)
	{
		switch (VisitExpr(value)) {
		case FuLiteralNull:
			break;
		case FuSymbolReference symbol when symbol.Symbol is FuClass klass:
			CheckIsHierarchy(switchPtr, statement.Value, klass, value, "case", "always match", "never match");
			break;
		case FuVar def:
			CheckIsVar(statement.Value, def, def, "case", "always match", "never match");
			break;
		default:
			ReportError(value, "Expected 'case Class'");
			break;
		}
	}

	void VisitSwitch!(FuSwitch! statement)
	{
		OpenScope(statement);
		statement.Value = VisitExpr(statement.Value);
		if (statement.Value != this.Poison && statement.Value.Type != this.Poison) {
			switch (statement.Value.Type) {
			case FuIntegerType i when i.Id != FuId.LongType:
				break;
			case FuEnum:
			// case FuStringType: matched by case FuClassType
				break;
			case FuClassType klass when !(klass is FuStorageType):
				break;
			default:
				ReportError(statement.Value, $"'switch' on type '{statement.Value.Type}' - expected 'int', 'enum', 'string' or object reference");
				break;
			}
		}
		statement.SetCompletesNormally(false);
		foreach (FuCase! kase in statement.Cases) {
			if (statement.Value != this.Poison) {
				for (int i = 0; i < kase.Values.Count; i++) {
					FuExpr# value = kase.Values[i];
					if (statement.Value.Type is FuClassType switchPtr && switchPtr.Class.Id != FuId.StringClass) {
						if (value is FuBinaryExpr! when1 && when1.Op == FuToken.When) {
							ResolveCaseType(statement, switchPtr, when1.Left);
							when1.Right = ResolveBool(when1.Right);
						}
						else
							ResolveCaseType(statement, switchPtr, value);
					}
					else if (value is FuBinaryExpr! when1 && when1.Op == FuToken.When) {
						when1.Left = FoldConst(when1.Left);
						Coerce(when1.Left, statement.Value.Type);
						when1.Right = ResolveBool(when1.Right);
					}
					else {
						kase.Values[i] = FoldConst(value);
						Coerce(kase.Values[i], statement.Value.Type);
					}
				}
			}
			if (ResolveStatements(kase.Body))
				ReportError(kase.Body.Last(), "'case' must end with 'break', 'continue', 'return' or 'throw'");
		}
		if (statement.DefaultBody.Count > 0) {
			bool reachable = ResolveStatements(statement.DefaultBody);
			if (reachable)
				ReportError(statement.DefaultBody.Last(), "'default' must end with 'break', 'continue', 'return' or 'throw'");
		}
		CloseScope();
	}

	void ResolveException!(FuSymbolReference# symbol)
	{
		if (VisitSymbolReference(symbol) is FuSymbolReference
		 && symbol.Symbol is FuClass && symbol.Symbol.Id == FuId.ExceptionClass) {
		}
		else
			ReportError(symbol, "Expected an exception class");
	}

	void VisitThrow!(FuThrow! statement)
	{
		ResolveException(statement.Class);
		if (statement.Class.Symbol is FuClass klass && !MethodHasThrows(this.CurrentMethod, klass))
			ReportError(statement, $"Method must be marked 'throws {klass.Name}'");
		if (statement.Message != null) {
			statement.Message = VisitExpr(statement.Message);
			if (!(statement.Message.Type is FuStringType))
				ReportError(statement.Message, "Exception accepts a string argument");
		}
	}

	void VisitWhile!(FuWhile! statement)
	{
		OpenScope(statement);
		ResolveLoopCond(statement);
		VisitStatement(statement.Body);
		CloseScope();
	}

	void VisitStatement!(FuStatement# statement)
	{
		switch (statement) {
		case FuAssert! asrt:
			VisitAssert(asrt);
			break;
		case FuBlock! block:
			VisitBlock(block);
			break;
		case FuBreak brk:
			brk.LoopOrSwitch.SetCompletesNormally(true);
			break;
		case FuContinue:
		case FuNative:
			break;
		case FuDoWhile! doWhile:
			VisitDoWhile(doWhile);
			break;
		case FuFor! forLoop:
			VisitFor(forLoop);
			break;
		case FuForeach! foreachLoop:
			VisitForeach(foreachLoop);
			break;
		case FuIf! ifStatement:
			VisitIf(ifStatement);
			break;
		case FuLock! lockStatement:
			VisitLock(lockStatement);
			break;
		case FuReturn! ret:
			VisitReturn(ret);
			break;
		case FuSwitch! switchStatement:
			VisitSwitch(switchStatement);
			break;
		case FuThrow! throwStatement:
			VisitThrow(throwStatement);
			break;
		case FuWhile! whileStatement:
			VisitWhile(whileStatement);
			break;
		case FuExpr# expr:
			VisitExpr(expr);
			break;
		default:
			assert false;
		}
	}

	FuExpr# FoldConst!(FuExpr# expr)
	{
		expr = VisitExpr(expr);
		if (expr is FuLiteral || expr.IsConstEnum())
			return expr;
		ReportError(expr, "Expected constant value");
		return expr;
	}

	int FoldConstInt!(FuExpr# expr)
	{
		if (FoldConst(expr) is FuLiteralLong# literal) {
			long l = literal.Value;
			if (l < int.MinValue || l > int.MaxValue) {
				ReportError(expr, "Only 32-bit ranges supported");
				return 0;
			}
			return l;
		}
		ReportError(expr, "Expected integer");
		return 0;
	}

	void ResolveConst!(FuConst! konst)
	{
		switch (konst.VisitStatus) {
		case FuVisitStatus.NotYet:
			break;
		case FuVisitStatus.InProgress:
			konst.Value = PoisonError(konst, $"Circular dependency in value of constant '{konst.Name}'");
			konst.VisitStatus = FuVisitStatus.Done;
			return;
		case FuVisitStatus.Done:
			return;
		}
		konst.VisitStatus = FuVisitStatus.InProgress;
		if (!(this.CurrentScope is FuEnum))
			ResolveType(konst);
		konst.Value = VisitExpr(konst.Value);
		if (konst.Value is FuAggregateInitializer! coll) {
			if (konst.Type is FuClassType array) {
				FuType# elementType = array.GetElementType();
				if (array is FuArrayStorageType arrayStg) {
					if (arrayStg.Length != coll.Items.Count)
						ReportError(konst, $"Declared {arrayStg.Length} elements, initialized {coll.Items.Count}");
				}
				else if (array is FuReadWriteClassType)
					ReportError(konst, "Invalid constant type");
				else
					konst.Type = new FuArrayStorageType { Class = this.Host.Program.System.ArrayStorageClass, TypeArg0 = elementType, Length = coll.Items.Count };
				coll.Type = konst.Type;
				foreach (FuExpr item in coll.Items)
					Coerce(item, elementType);
			}
			else
				ReportError(konst, $"Array initializer for scalar constant '{konst.Name}'");
		}
		else if (this.CurrentScope is FuEnum && konst.Value.Type is FuRangeType && konst.Value is FuLiteral) {
		}
		else if (konst.Value is FuLiteral || konst.Value.IsConstEnum())
			Coerce(konst.Value, konst.Type);
		else if (konst.Value != this.Poison)
			ReportError(konst.Value, $"Value for constant '{konst.Name}' is not constant");
		konst.InMethod = this.CurrentMethod;
		konst.VisitStatus = FuVisitStatus.Done;
	}

	void ResolveConsts!(FuContainerType! container)
	{
		this.CurrentScope = container;
		switch (container) {
		case FuClass klass:
			for (FuSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
				if (symbol is FuConst! konst)
					ResolveConst(konst);
			}
			break;
		case FuEnum! enu:
			FuConst? previous = null;
			for (FuSymbol!? symbol = enu.First; symbol != null; symbol = symbol.Next) {
				if (symbol is FuConst! konst) { // not HasFlag
					if (konst.Value != null) {
						ResolveConst(konst);
						enu.HasExplicitValue = true;
					}
					else
						konst.Value = new FuImplicitEnumValue { Value = previous == null ? 0 : previous.Value.IntValue() + 1 };
					previous = konst;
				}
			}
			break;
		default:
			assert false;
		}
	}

	void ResolveTypes!(FuClass! klass)
	{
		this.CurrentScope = klass;
		for (FuSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			switch (symbol) {
			case FuField! field:
				ResolveType(field);
				if (field.Visibility != FuVisibility.Protected)
					InitUnique(field);
				break;
			case FuMethod! method:
				if (method.TypeExpr == this.Host.Program.System.VoidType)
					method.Type = this.Host.Program.System.VoidType;
				else
					ResolveType(method);
				if (method.Name == "ToString" && method.CallType != FuCallType.Static && method.Parameters.Count() == 1)
					method.Id = FuId.ClassToString;
				for (FuVar!? param = method.FirstParameter(); param != null; param = param.NextVar()) {
					ResolveType(param);
					if (param.Value != null) {
						param.Value = FoldConst(param.Value);
						Coerce(param.Value, param.Type);
					}
				}
				if (method.Name == "Main") {
					if (method.Visibility != FuVisibility.Public || method.CallType != FuCallType.Static)
						ReportError(method, "'Main' method must be 'public static'");
					if (method.Type.Id != FuId.VoidType && method.Type.Id != FuId.IntType)
						ReportError(method.TypeExpr, "'Main' method must return 'void' or 'int'");
					switch (method.GetParametersCount()) {
					case 0:
						break;
					case 1:
						FuVar args = method.FirstParameter();
						if (args.Type is FuClassType! argsType && argsType.IsArray() && !(argsType is FuReadWriteClassType) && !argsType.Nullable) {
							FuType argsElement = argsType.GetElementType();
							if (argsElement.Id == FuId.StringPtrType && !argsElement.Nullable && args.Value == null) {
								argsType.Id = FuId.MainArgsType;
								argsType.Class = this.Host.Program.System.ArrayStorageClass;
								break;
							}
						}
						ReportError(args, "'Main' method parameter must be 'string[]'");
						break;
					default:
						ReportError(method, "'Main' method must have no parameters or one 'string[]' parameter");
						break;
					}
					if (this.Host.Program.Main != null)
						ReportError(method, "Duplicate 'Main' method");
					else {
						method.Id = FuId.Main;
						this.Host.Program.Main = method;
					}
				}
				foreach (FuSymbolReference# exception in method.Throws)
					ResolveException(exception);
				break;
			default:
				break;
			}
		}
	}

	void ResolveCode!(FuClass! klass)
	{
		if (klass.Constructor != null) {
			this.CurrentScope = klass.Constructor.Parameters;
			this.CurrentMethod = klass.Constructor;
			VisitStatement(klass.Constructor.Body);
			this.CurrentMethod = null;
		}
		for (FuSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			switch (symbol) {
			case FuField! field:
				if (field.Value != null) {
					field.Value = VisitExpr(field.Value);
					if (!field.IsAssignableStorage())
						CoercePermanent(field.Value, field.Type is FuArrayStorageType array ? array.GetElementType() : field.Type);
				}
				break;
			case FuMethod! method:
				if (method.Body != null) {
					if (method.CallType == FuCallType.Override || method.CallType == FuCallType.Sealed) {
						if (klass.Parent.TryLookup(method.Name, false) is FuMethod! baseMethod) {
							// TODO: check private
							if (!baseMethod.IsAbstractVirtualOrOverride())
								ReportError(method, "Base method is not abstract or virtual");
							else if (method.IsMutator() != baseMethod.IsMutator()) {
								if (method.IsMutator())
									ReportError(method, "Mutating method cannot override a non-mutating method");
								else
									ReportError(method, "Non-mutating method cannot override a mutating method");
							}
							if (!method.Type.EqualsType(baseMethod.Type))
								ReportError(method.TypeExpr, "Base method has a different return type");
							FuVar? baseParam = baseMethod.FirstParameter();
							for (FuVar? param = method.FirstParameter(); ; param = param.NextVar()) {
								if (param == null) {
									if (baseParam != null)
										ReportError(method, "Fewer parameters than the overridden method");
									break;
								}
								if (baseParam == null) {
									ReportError(param, "More parameters than the overridden method");
									break;
								}
								if (!param.Type.EqualsType(baseParam.Type)) {
									ReportError(param.TypeExpr, "Base method has a different parameter type");
									break;
								}
								baseParam = baseParam.NextVar();
							}
							baseMethod.Calls.Add(method);
						}
						else
							ReportError(method, "No method to override");
					}
					this.CurrentScope = method.Parameters;
					this.CurrentMethod = method;
					VisitStatement(method.Body);
					if (method.Type.Id != FuId.VoidType && method.Body.CompletesNormally())
						ReportError(method, "Method can complete without a return value");
					this.CurrentMethod = null;
				}
				break;
			default:
				break;
			}
		}
	}

	static void MarkMethodLive(FuMethodBase! method)
	{
		if (method.IsLive)
			return;
		method.IsLive = true;
		foreach (FuMethod! called in method.Calls)
			MarkMethodLive(called);
	}

	static void MarkClassLive(FuClass klass)
	{
		if (klass.IsPublic) {
			for (FuSymbol!? symbol = klass.First; symbol != null; symbol = symbol.Next) {
				if (symbol is FuMethod! method
				 && (method.Visibility == FuVisibility.Public || method.Visibility == FuVisibility.Protected))
					MarkMethodLive(method);
			}
		}
		if (klass.Constructor != null)
			MarkMethodLive(klass.Constructor);
	}

	public void Process!()
	{
		FuProgram program = this.Host.Program;
		for (FuSymbol!? type = program.First; type != null; type = type.Next) {
			if (type is FuClass! klass)
				ResolveBase(klass);
		}
		foreach (FuClass! klass in program.Classes)
			CheckBaseCycle(klass);
		for (FuSymbol!? type = program.First; type != null; type = type.Next) {
			assert type is FuContainerType! container;
			ResolveConsts(container);
		}
		foreach (FuClass! klass in program.Classes)
			ResolveTypes(klass);
		foreach (FuClass! klass in program.Classes)
			ResolveCode(klass);
		foreach (FuClass klass in program.Classes)
			MarkClassLive(klass);
	}
}
