// GenBaseBase.ci - base class for code generators
//
// Copyright (C) 2011-2023  Piotr Fusik
//
// This file is part of CiTo, see https://github.com/pfusik/cito
//
// CiTo is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CiTo is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CiTo.  If not, see http://www.gnu.org/licenses/

public abstract class GenBaseBase : CiExprVisitor
{
	internal string() Namespace;
	internal string() OutputFile;
	protected TextWriter! Writer; // TODO: private
	protected StringWriter! StringWriter; // TODO: private
	protected int Indent = 0;
	protected bool AtLineStart = true;
	bool AtChildStart = false;
	bool InChildBlock = false;
	protected CiMethodBase? CurrentMethod = null;
	protected HashSet<CiClass>() WrittenClasses;
	protected List<CiExpr>() CurrentTemporaries; // CiExpr or CiType

	protected override CiContainerType GetCurrentContainer()
	{
		assert this.CurrentMethod.Parent is CiClass klass;
		return klass;
	}

	protected abstract string GetTargetName();

	protected void NotSupported!(CiStatement statement, string feature)
	{
		ReportError(statement, $"{feature} not supported when targeting {GetTargetName()}");
	}

	protected void NotYet!(CiStatement statement, string feature)
	{
		ReportError(statement, $"{feature} not supported yet when targeting {GetTargetName()}");
	}

	protected virtual void StartLine!()
	{
		if (this.AtLineStart) {
			if (this.AtChildStart) {
				this.AtChildStart = false;
				this.Writer.WriteChar('\n');
				this.Indent++;
			}
			for (int i = 0; i < this.Indent; i++)
				this.Writer.WriteChar('\t');
			this.AtLineStart = false;
		}
	}

	protected void WriteChar!(int c)
	{
		StartLine();
		this.Writer.WriteChar(c);
	}

	protected void Write!(string s)
	{
		StartLine();
		this.Writer.Write(s);
	}

	public override void VisitLiteralNull!()
	{
		Write("null");
	}

	public override void VisitLiteralFalse!()
	{
		Write("false");
	}

	public override void VisitLiteralTrue!()
	{
		Write("true");
	}

	public override void VisitLiteralLong!(long i)
	{
		this.Writer.Write(i);
	}

	protected virtual int GetLiteralChars() => 0;

	public override void VisitLiteralChar!(int c)
	{
		if (c < GetLiteralChars()) {
			WriteChar('\'');
			switch (c) {
			case '\n': Write("\\n"); break;
			case '\r': Write("\\r"); break;
			case '\t': Write("\\t"); break;
			case '\'': Write("\\'"); break;
			case '\\': Write("\\\\"); break;
			default: WriteChar(c); break;
			}
			WriteChar('\'');
		}
		else
			this.Writer.Write(c);
	}

	public override void VisitLiteralString!(string value)
	{
		WriteChar('"');
		Write(value);
		WriteChar('"');
	}

	void WriteLowercaseChar!(int c)
	{
		if (c >= 'A' && c <= 'Z')
			c += 0x20;
		this.Writer.WriteChar(c);
	}

	void WriteUppercaseChar!(int c)
	{
		if (c >= 'a' && c <= 'z')
			c -= 0x20;
		this.Writer.WriteChar(c);
	}

	protected void WriteLowercase!(string s)
	{
		StartLine();
		foreach (int c in s)
			WriteLowercaseChar(c);
	}

	protected void WriteCamelCase!(string s)
	{
		StartLine();
		WriteLowercaseChar(s[0]);
		this.Writer.Write(s.Substring(1));
	}

	protected void WritePascalCase!(string s)
	{
		StartLine();
		WriteUppercaseChar(s[0]);
		this.Writer.Write(s.Substring(1));
	}

	protected void WriteUppercaseWithUnderscores!(string s)
	{
		StartLine();
		bool first = true;
		foreach (int c in s) {
			if (!first && c >= 'A' && c <= 'Z') {
				this.Writer.WriteChar('_');
				this.Writer.WriteChar(c);
			}
			else
				WriteUppercaseChar(c);
			first = false;
		}
	}

	protected void WriteLowercaseWithUnderscores!(string s)
	{
		StartLine();
		bool first = true;
		foreach (int c in s) {
			if (c >= 'A' && c <= 'Z') {
				if (!first)
					this.Writer.WriteChar('_');
				WriteLowercaseChar(c);
			}
			else
				this.Writer.WriteChar(c);
			first = false;
		}
	}

	protected void WriteNewLine!()
	{
		this.Writer.WriteChar('\n');
		this.AtLineStart = true;
	}

	protected void WriteCharLine!(int c)
	{
		WriteChar(c);
		WriteNewLine();
	}

	protected void WriteLine!(string s)
	{
		Write(s);
		WriteNewLine();
	}

	protected abstract void WriteName!(CiSymbol symbol);

	protected virtual void WriteBanner!()
	{
		WriteLine("// Generated automatically with \"cito\". Do not edit.");
	}

	protected virtual void StartDocLine!()
	{
		Write(" * ");
	}

	protected void WriteXmlDoc!(string text)
	{
		foreach (int c in text) {
			switch (c) {
			case '&':
				Write("&amp;");
				break;
			case '<':
				Write("&lt;");
				break;
			case '>':
				Write("&gt;");
				break;
			default:
				WriteChar(c);
				break;
			}
		}
	}

	protected virtual void WriteDocPara!(CiDocPara para, bool many)
	{
		if (many) {
			WriteNewLine();
			Write(" * <p>");
		}
		foreach (CiDocInline inline in para.Children) {
			switch (inline) {
			case CiDocText text:
				WriteXmlDoc(text.Text);
				break;
			case CiDocCode code:
				Write("<code>");
				WriteXmlDoc(code.Text);
				Write("</code>");
				break;
			case CiDocLine _:
				WriteNewLine();
				StartDocLine();
				break;
			default:
				assert false;
			}
		}
	}

	protected virtual void WriteDocList!(CiDocList list)
	{
		WriteNewLine();
		WriteLine(" * <ul>");
		foreach (CiDocPara item in list.Items) {
			Write(" * <li>");
			WriteDocPara(item, false);
			WriteLine("</li>");
		}
		Write(" * </ul>");
	}

	protected void WriteDocBlock!(CiDocBlock block, bool many)
	{
		switch (block) {
		case CiDocPara para:
			WriteDocPara(para, many);
			break;
		case CiDocList list:
			WriteDocList(list);
			break;
		default:
			assert false;
		}
	}

	protected void WriteContent!(CiCodeDoc doc)
	{
		StartDocLine();
		WriteDocPara(doc.Summary, false);
		WriteNewLine();
		if (doc.Details.Count > 0) {
			StartDocLine();
			if (doc.Details.Count == 1)
				WriteDocBlock(doc.Details[0], false);
			else {
				foreach (CiDocBlock block in doc.Details)
					WriteDocBlock(block, true);
			}
			WriteNewLine();
		}
	}

	protected virtual void WriteDoc!(CiCodeDoc? doc)
	{
		if (doc != null) {
			WriteLine("/**");
			WriteContent(doc);
			WriteLine(" */");
		}
	}

	protected virtual void WriteSelfDoc!(CiMethod method)
	{
	}

	protected virtual void WriteParameterDoc!(CiVar param, bool first)
	{
		Write(" * @param ");
		WriteName(param);
		WriteChar(' ');
		WriteDocPara(param.Documentation.Summary, false);
		WriteNewLine();
	}

	protected void WriteParametersDoc!(CiMethod method)
	{
		bool first = true;
		for (CiVar? param = method.Parameters.FirstParameter(); param != null; param = param.NextParameter()) {
			if (param.Documentation != null) {
				WriteParameterDoc(param, first);
				first = false;
			}
		}
	}

	protected void WriteMethodDoc!(CiMethod method)
	{
		if (method.Documentation == null)
			return;
		WriteLine("/**");
		WriteContent(method.Documentation);
		WriteSelfDoc(method);
		WriteParametersDoc(method);
		WriteLine(" */");
	}

	protected void WriteTopLevelNatives!(CiProgram program)
	{
		foreach (string content in program.TopLevelNatives)
			Write(content);
	}

	protected void OpenBlock!()
	{
		WriteCharLine('{');
		this.Indent++;
	}

	protected void CloseBlock!()
	{
		this.Indent--;
		WriteCharLine('}');
	}

	protected virtual void EndStatement!()
	{
		WriteCharLine(';');
	}

	protected void WriteComma!(int i)
	{
		if (i > 0) {
			if ((i & 15) == 0) {
				WriteCharLine(',');
				WriteChar('\t');
			}
			else
				Write(", ");
		}
	}

	protected abstract void WriteTypeAndName!(CiNamedValue value);

	protected virtual void WriteLocalName!(CiSymbol symbol, CiPriority parent)
	{
		if (symbol is CiField)
			Write("this.");
		WriteName(symbol);
	}

	protected void WriteDoubling!(string s, int doubled)
	{
		foreach (int c in s) {
			if (c == doubled)
				WriteChar(c);
			WriteChar(c);
		}
	}

	protected virtual void WritePrintfWidth!(CiInterpolatedPart part)
	{
		if (part.WidthExpr != null)
			VisitLiteralLong(part.Width);
		if (part.Precision >= 0) {
			WriteChar('.');
			VisitLiteralLong(part.Precision);
		}
	}

	static int GetPrintfFormat(CiType type, int format)
	{
		switch (type) {
		case CiIntegerType _:
			return format == 'x' || format == 'X' ? format : 'd';
		case CiNumericType _:
			switch (format) {
			case 'E':
			case 'e':
			case 'f':
			case 'G':
			case 'g':
				return format;
			case 'F':
				return 'f';
			default:
				return 'g';
			}
		// case CiStringType _: - matched by CiClassType
		case CiClassType _:
			return 's';
		default:
			assert false;
		}
	}

	protected void WritePrintfFormat!(CiInterpolatedString expr)
	{
		foreach (CiInterpolatedPart part in expr.Parts) {
			WriteDoubling(part.Prefix, '%');
			WriteChar('%');
			WritePrintfWidth(part);
			WriteChar(GetPrintfFormat(part.Argument.Type, part.Format));
		}
		WriteDoubling(expr.Suffix, '%');
	}

	protected virtual void WriteInterpolatedStringArg!(CiExpr expr)
	{
		expr.Accept(this, CiPriority.Argument);
	}

	protected void WriteInterpolatedStringArgs!(CiInterpolatedString expr)
	{
		foreach (CiInterpolatedPart part in expr.Parts) {
			Write(", ");
			WriteInterpolatedStringArg(part.Argument);
		}
	}

	protected void WritePrintf!(CiInterpolatedString expr, bool newLine)
	{
		WriteChar('"');
		WritePrintfFormat(expr);
		if (newLine)
			Write("\\n");
		WriteChar('"');
		WriteInterpolatedStringArgs(expr);
		WriteChar(')');
	}

	protected void WritePostfix!(CiExpr obj, string s)
	{
		obj.Accept(this, CiPriority.Primary);
		Write(s);
	}

	protected void WriteCall!(string function, CiExpr arg0, CiExpr? arg1 = null, CiExpr? arg2 = null)
	{
		Write(function);
		WriteChar('(');
		arg0.Accept(this, CiPriority.Argument);
		if (arg1 != null) {
			Write(", ");
			arg1.Accept(this, CiPriority.Argument);
			if (arg2 != null) {
				Write(", ");
				arg2.Accept(this, CiPriority.Argument);
			}
		}
		WriteChar(')');
	}

	protected virtual void WriteMemberOp!(CiExpr left, CiSymbolReference? symbol)
	{
		WriteChar('.');
	}

	protected void WriteMethodCall!(CiExpr obj, string method, CiExpr arg0, CiExpr? arg1 = null)
	{
		obj.Accept(this, CiPriority.Primary);
		WriteMemberOp(obj, null);
		WriteCall(method, arg0, arg1);
	}

	protected virtual void WriteSelectValues!(CiType type, CiSelectExpr expr)
	{
		WriteCoerced(type, expr.OnTrue, CiPriority.Select);
		Write(" : ");
		WriteCoerced(type, expr.OnFalse, CiPriority.Select);
	}

	protected virtual void WriteCoercedSelect!(CiType type, CiSelectExpr expr, CiPriority parent)
	{
		if (parent > CiPriority.Select)
			WriteChar('(');
		expr.Cond.Accept(this, CiPriority.Select);
		Write(" ? ");
		WriteSelectValues(type, expr);
		if (parent > CiPriority.Select)
			WriteChar(')');
	}

	protected virtual void WriteCoercedInternal!(CiType type, CiExpr expr, CiPriority parent)
	{
		expr.Accept(this, parent);
	}

	protected void WriteCoerced!(CiType type, CiExpr expr, CiPriority parent)
	{
		if (expr is CiSelectExpr select)
			WriteCoercedSelect(type, select, parent);
		else
			WriteCoercedInternal(type, expr, parent);
	}

	protected virtual void WriteCoercedExpr!(CiType type, CiExpr expr)
	{
		WriteCoerced(type, expr, CiPriority.Argument);
	}

	protected virtual void WriteStronglyCoerced!(CiType type, CiExpr expr)
	{
		WriteCoerced(type, expr, CiPriority.Argument);
	}

	protected virtual void WriteCoercedLiteral!(CiType type, CiExpr literal)
	{
		literal.Accept(this, CiPriority.Argument);
	}

	protected void WriteCoercedLiterals!(CiType type, List<CiExpr#> exprs)
	{
		for (int i = 0; i < exprs.Count; i++) {
			WriteComma(i);
			WriteCoercedLiteral(type, exprs[i]);
		}
	}

	protected void WriteArgs!(CiMethod method, List<CiExpr> args)
	{
		CiVar param = method.Parameters.FirstParameter();
		bool first = true;
		foreach (CiExpr arg in args) {
			if (!first)
				Write(", ");
			first = false;
			WriteStronglyCoerced(param.Type, arg);
			param = param.NextParameter();
		}
	}

	protected void WriteArgsInParentheses!(CiMethod method, List<CiExpr> args)
	{
		WriteChar('(');
		WriteArgs(method, args);
		WriteChar(')');
	}

	protected abstract void WriteNewArray!(CiType elementType, CiExpr lengthExpr, CiPriority parent);

	protected virtual void WriteNewArrayStorage!(CiArrayStorageType array)
	{
		WriteNewArray(array.GetElementType(), array.LengthExpr, CiPriority.Argument);
	}

	protected abstract void WriteNew!(CiReadWriteClassType klass, CiPriority parent);

	protected void WriteNewStorage!(CiType type)
	{
		switch (type) {
		case CiArrayStorageType array:
			WriteNewArrayStorage(array);
			break;
		case CiStorageType storage:
			WriteNew(storage, CiPriority.Argument);
			break;
		default:
			assert false;
		}
	}

	protected virtual void WriteArrayStorageInit!(CiArrayStorageType array, CiExpr value)
	{
		Write(" = ");
		WriteNewArrayStorage(array);
	}

	protected virtual void WriteNewWithFields!(CiReadWriteClassType type, CiAggregateInitializer init)
	{
		WriteNew(type, CiPriority.Argument);
	}

	protected virtual void WriteStorageInit!(CiNamedValue def)
	{
		Write(" = ");
		if (def.Value is CiAggregateInitializer init) {
			assert def.Type is CiReadWriteClassType klass;
			WriteNewWithFields(klass, init);
		}
		else
			WriteNewStorage(def.Type);
	}

	protected virtual void WriteVarInit!(CiNamedValue def)
	{
		if (def.IsAssignableStorage()) {
		}
		else if (def.Type is CiArrayStorageType array)
			WriteArrayStorageInit(array, def.Value);
		else if (def.Value != null && !(def.Value is CiAggregateInitializer)) {
			Write(" = ");
			WriteCoercedExpr(def.Type, def.Value);
		}
		else if (def.Type.IsFinal() && !(def.Parent is CiParameters))
			WriteStorageInit(def);
	}

	protected virtual void WriteVar!(CiNamedValue def)
	{
		WriteTypeAndName(def);
		WriteVarInit(def);
	}

	public override void VisitVar!(CiVar expr)
	{
		WriteVar(expr);
	}

	protected void WriteObjectLiteral!(CiAggregateInitializer init, string separator)
	{
		string prefix = " { ";
		foreach (CiExpr item in init.Items) {
			Write(prefix);
			assert item is CiBinaryExpr assign;
			assert assign.Left is CiSymbolReference field;
			WriteName(field.Symbol);
			Write(separator);
			WriteCoerced(assign.Left.Type, assign.Right, CiPriority.Argument);
			prefix = ", ";
		}
		Write(" }");
	}

	protected static CiAggregateInitializer? GetAggregateInitializer!(CiNamedValue def) // TODO: private
	{
		CiExpr expr = def.Value;
		if (expr is CiPrefixExpr unary)
			expr = unary.Inner;
		return expr is CiAggregateInitializer init ? init : null;
	}

	void WriteAggregateInitField!(CiExpr obj, CiExpr item)
	{
		assert item is CiBinaryExpr assign;
		assert assign.Left is CiSymbolReference field;
		WriteMemberOp(obj, field);
		WriteName(field.Symbol);
		Write(" = ");
		WriteCoerced(field.Type, assign.Right, CiPriority.Argument);
		EndStatement();
	}

	protected virtual void WriteInitCode!(CiNamedValue def)
	{
		CiAggregateInitializer? init = GetAggregateInitializer(def);
		if (init != null) {
			foreach (CiExpr item in init.Items) {
				WriteLocalName(def, CiPriority.Primary);
				WriteAggregateInitField(def, item);
			}
		}
	}

	protected virtual void DefineIsVar!(CiBinaryExpr binary)
	{
		if (binary.Right is CiVar def) {
			EnsureChildBlock();
			WriteVar(def);
			EndStatement();
		}
	}

	protected void WriteArrayElement!(CiNamedValue def, int nesting)
	{
		WriteLocalName(def, CiPriority.Primary);
		for (int i = 0; i < nesting; i++) {
			Write("[_i");
			VisitLiteralLong(i);
			WriteChar(']');
		}
	}

	protected void OpenLoop!(string intString, int nesting, int count)
	{
		Write("for (");
		Write(intString);
		Write(" _i");
		VisitLiteralLong(nesting);
		Write(" = 0; _i");
		VisitLiteralLong(nesting);
		Write(" < ");
		VisitLiteralLong(count);
		Write("; _i");
		VisitLiteralLong(nesting);
		Write("++) ");
		OpenBlock();
	}

	protected abstract void WriteResource!(string name, int length);

	public override void VisitPrefixExpr!(CiPrefixExpr expr, CiPriority parent)
	{
		switch (expr.Op) {
		case CiToken.Increment:
			Write("++");
			break;
		case CiToken.Decrement:
			Write("--");
			break;
		case CiToken.Minus:
			WriteChar('-');
			// FIXME: - --foo[bar]
			if (expr.Inner is CiPrefixExpr inner && (inner.Op == CiToken.Minus || inner.Op == CiToken.Decrement))
				WriteChar(' ');
			break;
		case CiToken.Tilde:
			WriteChar('~');
			break;
		case CiToken.ExclamationMark:
			WriteChar('!');
			break;
		case CiToken.New:
			assert expr.Type is CiDynamicPtrType dynamic;
			if (dynamic.Class.Id == CiId.ArrayPtrClass)
				WriteNewArray(dynamic.GetElementType(), expr.Inner, parent);
			else if (expr.Inner is CiAggregateInitializer init) {
				int tempId = this.CurrentTemporaries.IndexOf(expr);
				if (tempId >= 0) {
					Write("citemp");
					VisitLiteralLong(tempId);
				}
				else
					WriteNewWithFields(dynamic, init);
			}
			else
				WriteNew(dynamic, parent);
			return;
		case CiToken.Resource:
			assert expr.Inner is CiLiteralString name;
			assert expr.Type is CiArrayStorageType array;
			WriteResource(name.Value, array.Length);
			return;
		default:
			assert false;
		}
		expr.Inner.Accept(this, CiPriority.Primary);
	}

	public override void VisitPostfixExpr!(CiPostfixExpr expr, CiPriority parent)
	{
		expr.Inner.Accept(this, CiPriority.Primary);
		switch (expr.Op) {
		case CiToken.Increment:
			Write("++");
			break;
		case CiToken.Decrement:
			Write("--");
			break;
		default:
			assert false;
		}
	}

	protected void StartAdd!(CiExpr expr)
	{
		if (!expr.IsLiteralZero()) {
			expr.Accept(this, CiPriority.Add);
			Write(" + ");
		}
	}

	protected void WriteAdd!(CiExpr left, CiExpr right)
	{
		if (left is CiLiteralLong leftLiteral) {
			long leftValue = leftLiteral.Value;
			if (leftValue == 0) {
				right.Accept(this, CiPriority.Argument);
				return;
			}
			if (right is CiLiteralLong rightLiteral) {
				VisitLiteralLong(leftValue + rightLiteral.Value);
				return;
			}
		}
		else if (right.IsLiteralZero()) {
			left.Accept(this, CiPriority.Argument);
			return;
		}
		left.Accept(this, CiPriority.Add);
		Write(" + ");
		right.Accept(this, CiPriority.Add);
	}

	protected void WriteStartEnd!(CiExpr startIndex, CiExpr length)
	{
		startIndex.Accept(this, CiPriority.Argument);
		Write(", ");
		WriteAdd(startIndex, length); // TODO: side effect
	}

	static bool IsBitOp(CiPriority parent)
	{
		switch (parent) {
		case CiPriority.Or:
		case CiPriority.Xor:
		case CiPriority.And:
		case CiPriority.Shift:
			return true;
		default:
			return false;
		}
	}

	protected virtual void WriteBinaryOperand!(CiExpr expr, CiPriority parent, CiBinaryExpr binary)
	{
		expr.Accept(this, parent);
	}

	protected void WriteBinaryExpr!(CiBinaryExpr expr, bool parentheses, CiPriority left, string op, CiPriority right)
	{
		if (parentheses)
			WriteChar('(');
		WriteBinaryOperand(expr.Left, left, expr);
		Write(op);
		WriteBinaryOperand(expr.Right, right, expr);
		if (parentheses)
			WriteChar(')');
	}

	protected void WriteBinaryExpr2!(CiBinaryExpr expr, CiPriority parent, CiPriority child, string op)
	{
		WriteBinaryExpr(expr, parent > child, child, op, child);
	}

	protected static string GetEqOp(bool not) => not ? " != " : " == ";

	protected virtual void WriteEqual!(CiBinaryExpr expr, CiPriority parent, bool not)
	{
		WriteBinaryExpr2(expr, parent, CiPriority.Equality, GetEqOp(not));
	}

	protected virtual void WriteAnd!(CiBinaryExpr expr, CiPriority parent)
	{
		WriteBinaryExpr(expr, parent > CiPriority.CondAnd && parent != CiPriority.And, CiPriority.And, " & ", CiPriority.And);
	}

	protected virtual void WriteAssignRight!(CiBinaryExpr expr)
	{
		WriteCoerced(expr.Left.Type, expr.Right, CiPriority.Argument);
	}

	protected virtual void WriteAssign!(CiBinaryExpr expr, CiPriority parent)
	{
		if (parent > CiPriority.Assign)
			WriteChar('(');
		expr.Left.Accept(this, CiPriority.Assign);
		Write(" = ");
		WriteAssignRight(expr);
		if (parent > CiPriority.Assign)
			WriteChar(')');
	}

	protected void WriteIndexing!(CiExpr collection, CiExpr index)
	{
		collection.Accept(this, CiPriority.Primary);
		WriteChar('[');
		index.Accept(this, CiPriority.Argument);
		WriteChar(']');
	}

	protected virtual void WriteIndexingExpr!(CiBinaryExpr expr, CiPriority parent)
	{
		WriteIndexing(expr.Left, expr.Right);
	}

	protected virtual string GetIsOperator() => " is ";

	public override void VisitBinaryExpr!(CiBinaryExpr expr, CiPriority parent)
	{
		switch (expr.Op) {
		case CiToken.Plus:
			WriteBinaryExpr(expr, parent > CiPriority.Add || IsBitOp(parent), CiPriority.Add, " + ", CiPriority.Add);
			break;
		case CiToken.Minus:
			WriteBinaryExpr(expr, parent > CiPriority.Add || IsBitOp(parent), CiPriority.Add, " - ", CiPriority.Mul);
			break;
		case CiToken.Asterisk:
			WriteBinaryExpr2(expr, parent, CiPriority.Mul, " * ");
			break;
		case CiToken.Slash:
			WriteBinaryExpr(expr, parent > CiPriority.Mul, CiPriority.Mul, " / ", CiPriority.Primary);
			break;
		case CiToken.Mod:
			WriteBinaryExpr(expr, parent > CiPriority.Mul, CiPriority.Mul, " % ", CiPriority.Primary);
			break;
		case CiToken.ShiftLeft:
			WriteBinaryExpr(expr, parent > CiPriority.Shift, CiPriority.Shift, " << ", CiPriority.Mul);
			break;
		case CiToken.ShiftRight:
			WriteBinaryExpr(expr, parent > CiPriority.Shift, CiPriority.Shift, " >> ", CiPriority.Mul);
			break;
		case CiToken.Less:
			WriteBinaryExpr2(expr, parent, CiPriority.Rel, " < ");
			break;
		case CiToken.LessOrEqual:
			WriteBinaryExpr2(expr, parent, CiPriority.Rel, " <= ");
			break;
		case CiToken.Greater:
			WriteBinaryExpr2(expr, parent, CiPriority.Rel, " > ");
			break;
		case CiToken.GreaterOrEqual:
			WriteBinaryExpr2(expr, parent, CiPriority.Rel, " >= ");
			break;
		case CiToken.Equal:
			WriteEqual(expr, parent, false);
			break;
		case CiToken.NotEqual:
			WriteEqual(expr, parent, true);
			break;
		case CiToken.And:
			WriteAnd(expr, parent);
			break;
		case CiToken.Or:
			WriteBinaryExpr2(expr, parent, CiPriority.Or, " | ");
			break;
		case CiToken.Xor:
			WriteBinaryExpr(expr, parent > CiPriority.Xor || parent == CiPriority.Or, CiPriority.Xor, " ^ ", CiPriority.Xor);
			break;
		case CiToken.CondAnd:
			WriteBinaryExpr(expr, parent > CiPriority.CondAnd || parent == CiPriority.CondOr, CiPriority.CondAnd, " && ", CiPriority.CondAnd);
			break;
		case CiToken.CondOr:
			WriteBinaryExpr2(expr, parent, CiPriority.CondOr, " || ");
			break;
		case CiToken.Assign:
			WriteAssign(expr, parent);
			break;
		case CiToken.AddAssign:
		case CiToken.SubAssign:
		case CiToken.MulAssign:
		case CiToken.DivAssign:
		case CiToken.ModAssign:
		case CiToken.ShiftLeftAssign:
		case CiToken.ShiftRightAssign:
		case CiToken.AndAssign:
		case CiToken.OrAssign:
		case CiToken.XorAssign:
			if (parent > CiPriority.Assign)
				WriteChar('(');
			expr.Left.Accept(this, CiPriority.Assign);
			WriteChar(' ');
			Write(expr.GetOpString());
			WriteChar(' ');
			expr.Right.Accept(this, CiPriority.Argument);
			if (parent > CiPriority.Assign)
				WriteChar(')');
			break;

		case CiToken.LeftBracket:
			if (expr.Left.Type is CiStringType)
				WriteCharAt(expr);
			else
				WriteIndexingExpr(expr, parent);
			break;

		case CiToken.Is:
			if (parent > CiPriority.Rel)
				WriteChar('(');
			expr.Left.Accept(this, CiPriority.Rel);
			Write(GetIsOperator());
			switch (expr.Right) {
			case CiSymbolReference symbol:
				WriteName(symbol.Symbol);
				break;
			case CiVar def:
				WriteTypeAndName(def);
				break;
			default:
				assert false;
			}
			if (parent > CiPriority.Rel)
				WriteChar(')');
			break;

		case CiToken.When:
			expr.Left.Accept(this, CiPriority.Argument);
			Write(" when ");
			expr.Right.Accept(this, CiPriority.Argument);
			break;

		default:
			assert false;
		}
	}

	protected abstract void WriteStringLength!(CiExpr expr);

	protected static bool IsReferenceTo(CiExpr expr, CiId id) => expr is CiSymbolReference symbol && symbol.Symbol.Id == id;

	protected bool WriteJavaMatchProperty!(CiSymbolReference expr, CiPriority parent)
	{
		switch (expr.Symbol.Id) {
		case CiId.MatchStart:
			WritePostfix(expr.Left, ".start()");
			return true;
		case CiId.MatchEnd:
			WritePostfix(expr.Left, ".end()");
			return true;
		case CiId.MatchLength:
			if (parent > CiPriority.Add)
				WriteChar('(');
			WritePostfix(expr.Left, ".end() - ");
			WritePostfix(expr.Left, ".start()"); // FIXME: side effect
			if (parent > CiPriority.Add)
				WriteChar(')');
			return true;
		case CiId.MatchValue:
			WritePostfix(expr.Left, ".group()");
			return true;
		default:
			return false;
		}
	}

	public override void VisitSymbolReference!(CiSymbolReference expr, CiPriority parent)
	{
		if (expr.Left == null)
			WriteLocalName(expr.Symbol, parent);
		else if (expr.Symbol.Id == CiId.StringLength)
			WriteStringLength(expr.Left);
		else {
			expr.Left.Accept(this, CiPriority.Primary);
			WriteMemberOp(expr.Left, expr);
			WriteName(expr.Symbol);
		}
	}

	protected abstract void WriteCharAt!(CiBinaryExpr expr);

	protected virtual void WriteNotPromoted!(CiType type, CiExpr expr)
	{
		expr.Accept(this, CiPriority.Argument);
	}

	protected void WriteListAdd!(CiExpr obj, string method, List<CiExpr#> args)
	{
		obj.Accept(this, CiPriority.Primary);
		WriteChar('.');
		Write(method);
		WriteChar('(');
		assert obj.Type is CiClassType klass;
		CiType elementType = klass.GetElementType();
		if (args.Count == 0)
			WriteNewStorage(elementType);
		else
			WriteNotPromoted(elementType, args[0]);
		WriteChar(')');
	}

	protected void WriteListInsert!(CiExpr obj, string method, List<CiExpr#> args, string separator = ", ")
	{
		obj.Accept(this, CiPriority.Primary);
		WriteChar('.');
		Write(method);
		WriteChar('(');
		args[0].Accept(this, CiPriority.Argument);
		Write(separator);
		assert obj.Type is CiClassType klass;
		CiType elementType = klass.GetElementType();
		if (args.Count == 1)
			WriteNewStorage(elementType);
		else
			WriteNotPromoted(elementType, args[1]);
		WriteChar(')');
	}

	protected void WriteDictionaryAdd!(CiExpr obj, List<CiExpr#> args)
	{
		WriteIndexing(obj, args[0]);
		Write(" = ");
		assert obj.Type is CiClassType dict;
		WriteNewStorage(dict.GetValueType());
	}

	protected void WriteClampAsMinMax!(List<CiExpr#> args)
	{
		args[0].Accept(this, CiPriority.Argument);
		Write(", ");
		args[1].Accept(this, CiPriority.Argument);
		Write("), ");
		args[2].Accept(this, CiPriority.Argument);
		WriteChar(')');
	}

	protected abstract void WriteCallExpr!(CiExpr obj, CiMethod method, List<CiExpr#> args, CiPriority parent);

	public override void VisitCallExpr!(CiCallExpr expr, CiPriority parent)
	{
		assert expr.Method.Symbol is CiMethod method;
		WriteCallExpr(expr.Method.Left, method, expr.Arguments, parent);
	}

	public override void VisitSelectExpr!(CiSelectExpr expr, CiPriority parent)
	{
		WriteCoercedSelect(expr.Type, expr, parent);
	}

	protected void EnsureChildBlock!()
	{
		if (this.AtChildStart) {
			this.AtLineStart = false;
			this.AtChildStart = false;
			WriteChar(' ');
			OpenBlock();
			this.InChildBlock = true;
		}
	}

	protected abstract void StartTemporaryVar!(CiType type);

	protected virtual void DefineObjectLiteralTemporary!(CiUnaryExpr expr)
	{
		if (expr.Inner is CiAggregateInitializer init) {
			EnsureChildBlock();
			int id = this.CurrentTemporaries.IndexOf(expr.Type);
			if (id < 0) {
				id = this.CurrentTemporaries.Count;
				StartTemporaryVar(expr.Type);
				this.CurrentTemporaries.Add(expr);
			}
			else
				this.CurrentTemporaries[id] = expr;
			Write("citemp");
			VisitLiteralLong(id);
			Write(" = ");
			assert expr.Type is CiDynamicPtrType dynamic;
			WriteNew(dynamic, CiPriority.Argument);
			EndStatement();
			foreach (CiExpr item in init.Items) {
				Write("citemp");
				VisitLiteralLong(id);
				WriteAggregateInitField(expr, item);
			}
		}
	}

	protected void WriteTemporaries!(CiExpr expr)
	{
		switch (expr) {
		case CiVar def:
			if (def.Value != null) {
				if (def.Value is CiUnaryExpr unary && unary.Inner is CiAggregateInitializer)
					WriteTemporaries(unary.Inner);
				else
					WriteTemporaries(def.Value);
			}
			break;
		case CiAggregateInitializer init:
			foreach (CiExpr item in init.Items) {
				assert item is CiBinaryExpr assign;
				WriteTemporaries(assign.Right);
			}
			break;
		case CiLiteral _:
		case CiLambdaExpr _:
			break;
		case CiInterpolatedString interp:
			foreach (CiInterpolatedPart part in interp.Parts)
				WriteTemporaries(part.Argument);
			break;
		case CiSymbolReference symbol:
			if (symbol.Left != null)
				WriteTemporaries(symbol.Left);
			break;
		case CiUnaryExpr unary:
			if (unary.Inner != null) {
				WriteTemporaries(unary.Inner);
				DefineObjectLiteralTemporary(unary);
			}
			break;
		case CiBinaryExpr binary:
			WriteTemporaries(binary.Left);
			if (binary.Op == CiToken.Is)
				DefineIsVar(binary);
			else
				WriteTemporaries(binary.Right);
			break;
		case CiSelectExpr select:
			WriteTemporaries(select.Cond);
			WriteTemporaries(select.OnTrue);
			WriteTemporaries(select.OnFalse);
			break;
		case CiCallExpr call:
			WriteTemporaries(call.Method);
			foreach (CiExpr arg in call.Arguments)
				WriteTemporaries(arg);
			break;
		default:
			assert false;
		}
	}

	protected virtual void CleanupTemporary!(int i, CiExpr temp)
	{
	}

	protected void CleanupTemporaries!()
	{
		for (int i = this.CurrentTemporaries.Count; --i >= 0; ) {
			CiExpr temp = this.CurrentTemporaries[i];
			if (!(temp is CiType)) {
				CleanupTemporary(i, temp);
				this.CurrentTemporaries[i] = temp.Type;
			}
		}
	}

	public override void VisitExpr!(CiExpr! statement)
	{
		WriteTemporaries(statement);
		statement.Accept(this, CiPriority.Statement);
		WriteCharLine(';');
		if (statement is CiVar def)
			WriteInitCode(def);
		CleanupTemporaries();
	}

	public override void VisitConst!(CiConst statement)
	{
	}

	protected abstract void WriteAssertCast!(CiBinaryExpr expr);

	protected abstract void WriteAssert!(CiAssert statement);

	public override void VisitAssert!(CiAssert! statement)
	{
		if (statement.Cond is CiBinaryExpr binary && binary.Op == CiToken.Is && binary.Right is CiVar)
			WriteAssertCast(binary);
		else
			WriteAssert(statement);
	}

	protected void WriteFirstStatements!(List<CiStatement#> statements, int count)
	{
		for (int i = 0; i < count; i++)
			statements[i].AcceptStatement(this);
	}

	protected virtual void WriteStatements!(List<CiStatement#> statements)
	{
		WriteFirstStatements(statements, statements.Count);
	}

	protected virtual void CleanupBlock!(CiBlock statement)
	{
	}

	public override void VisitBlock!(CiBlock! statement)
	{
		if (this.AtChildStart) {
			this.AtLineStart = false;
			this.AtChildStart = false;
			WriteChar(' ');
		}
		OpenBlock();
		int temporariesCount = this.CurrentTemporaries.Count;
		WriteStatements(statement.Statements);
		CleanupBlock(statement);
		this.CurrentTemporaries.RemoveRange(temporariesCount, this.CurrentTemporaries.Count - temporariesCount);
		CloseBlock();
	}

	protected virtual void WriteChild!(CiStatement! statement)
	{
		bool wasInChildBlock = this.InChildBlock;
		this.AtLineStart = true;
		this.AtChildStart = true;
		this.InChildBlock = false;
		statement.AcceptStatement(this);
		if (this.InChildBlock)
			CloseBlock();
		else if (!(statement is CiBlock))
			this.Indent--;
		this.InChildBlock = wasInChildBlock;
	}

	public override void VisitBreak!(CiBreak! statement)
	{
		WriteLine("break;");
	}

	public override void VisitContinue!(CiContinue! statement)
	{
		WriteLine("continue;");
	}

	public override void VisitDoWhile!(CiDoWhile! statement)
	{
		Write("do");
		WriteChild(statement.Body);
		Write("while (");
		statement.Cond.Accept(this, CiPriority.Argument);
		WriteLine(");");
	}

	public override void VisitFor!(CiFor! statement)
	{
		Write("for (");
		if (statement.Init != null)
			statement.Init.Accept(this, CiPriority.Statement);
		WriteChar(';');
		if (statement.Cond != null) {
			WriteChar(' ');
			statement.Cond.Accept(this, CiPriority.Argument);
		}
		WriteChar(';');
		if (statement.Advance != null) {
			WriteChar(' ');
			statement.Advance.Accept(this, CiPriority.Statement);
		}
		WriteChar(')');
		WriteChild(statement.Body);
	}

	protected virtual bool EmbedIfWhileIsVar!(CiExpr expr, bool write) => false;

	protected void StartIfWhile!(CiExpr expr) // TODO: private
	{
		EmbedIfWhileIsVar(expr, true);
		expr.Accept(this, CiPriority.Argument);
		WriteChar(')');
	}

	void WriteIf!(CiIf! statement)
	{
		Write("if (");
		StartIfWhile(statement.Cond);
		WriteChild(statement.OnTrue);
		if (statement.OnFalse != null) {
			Write("else");
			if (statement.OnFalse is CiIf! elseIf) {
				bool wasInChildBlock = this.InChildBlock;
				this.AtLineStart = true;
				this.AtChildStart = true;
				this.InChildBlock = false;
				if (!EmbedIfWhileIsVar(elseIf.Cond, false)) // FIXME: IsVar but not object literal
					WriteTemporaries(elseIf.Cond);
				if (this.InChildBlock) {
					WriteIf(elseIf);
					CloseBlock();
				}
				else {
					this.AtLineStart = false;
					this.AtChildStart = false;
					WriteChar(' ');
					WriteIf(elseIf);
				}
				this.InChildBlock = wasInChildBlock;
			}
			else
				WriteChild(statement.OnFalse);
		}
	}

	public override void VisitIf!(CiIf! statement)
	{
		if (!EmbedIfWhileIsVar(statement.Cond, false)) // FIXME: IsVar but not object literal
			WriteTemporaries(statement.Cond);
		WriteIf(statement);
	}

	public override void VisitNative!(CiNative! statement)
	{
		Write(statement.Content);
	}

	public override void VisitReturn!(CiReturn! statement)
	{
		if (statement.Value == null)
			WriteLine("return;");
		else {
			WriteTemporaries(statement.Value);
			Write("return ");
			WriteStronglyCoerced(this.CurrentMethod.Type, statement.Value);
			WriteCharLine(';');
			CleanupTemporaries();
		}
	}

	protected void DefineVar!(CiVar def)
	{
		if (def.Name != "_") {
			WriteVar(def);
			EndStatement();
		}
	}

	protected void WriteSwitchWhenVars!(CiSwitch statement, bool whenOnly = true)
	{
		foreach (CiCase kase in statement.Cases) {
			foreach (CiExpr value in kase.Values) {
				if (!whenOnly && value is CiVar var)
					DefineVar(var);
				else if (value is CiBinaryExpr when1 && when1.Op == CiToken.When) {
					assert when1.Left is CiVar whenVar;
					DefineVar(whenVar);
					WriteTemporaries(when1);
				}
			}
		}
	}

	protected virtual void WriteSwitchValue!(CiExpr expr)
	{
		expr.Accept(this, CiPriority.Argument);
	}

	protected virtual void WriteSwitchCaseBody!(List<CiStatement#> statements)
	{
		WriteStatements(statements);
	}

	protected virtual void WriteSwitchCase!(CiSwitch statement, CiCase kase)
	{
		foreach (CiExpr value in kase.Values) {
			Write("case ");
			WriteCoercedLiteral(statement.Value.Type, value);
			WriteCharLine(':');
		}
		this.Indent++;
		WriteSwitchCaseBody(kase.Body);
		this.Indent--;
	}

	public override void VisitSwitch!(CiSwitch! statement)
	{
		WriteTemporaries(statement.Value);
		Write("switch (");
		WriteSwitchValue(statement.Value);
		WriteLine(") {");
		foreach (CiCase kase in statement.Cases)
			WriteSwitchCase(statement, kase);
		if (statement.DefaultBody.Count > 0) {
			WriteLine("default:");
			this.Indent++;
			WriteSwitchCaseBody(statement.DefaultBody);
			this.Indent--;
		}
		WriteCharLine('}');
	}

	public override void VisitWhile!(CiWhile! statement)
	{
		if (!EmbedIfWhileIsVar(statement.Cond, false)) // FIXME: IsVar but not object literal
			WriteTemporaries(statement.Cond);
		Write("while (");
		StartIfWhile(statement.Cond);
		WriteChild(statement.Body);
	}

	protected void FlattenBlock!(CiStatement! statement)
	{
		if (statement is CiBlock block)
			WriteStatements(block.Statements);
		else
			statement.AcceptStatement(this);
	}

	protected virtual bool HasInitCode(CiNamedValue def) => GetAggregateInitializer(def) != null;

	protected virtual bool NeedsConstructor(CiClass klass)
	{
		for (CiSymbol? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			if (symbol is CiField field && HasInitCode(field))
				return true;
		}
		return klass.Constructor != null;
	}

	protected virtual void WriteInitField!(CiField field)
	{
		WriteInitCode(field);
	}

	protected void WriteConstructorBody!(CiClass klass)
	{
		for (CiSymbol? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			if (symbol is CiField field)
				WriteInitField(field);
		}
		if (klass.Constructor != null) {
			this.CurrentMethod = klass.Constructor;
			assert klass.Constructor.Body is CiBlock block;
			WriteStatements(block.Statements);
			this.CurrentMethod = null;
		}
		this.CurrentTemporaries.Clear();
	}

	protected virtual void WriteParameter!(CiVar param)
	{
		WriteTypeAndName(param);
	}

	protected void WriteRemainingParameters!(CiMethod method, bool first, bool defaultArguments)
	{
		for (CiVar? param = method.Parameters.FirstParameter(); param != null; param = param.NextParameter()) {
			if (!first)
				Write(", ");
			first = false;
			WriteParameter(param);
			if (defaultArguments)
				WriteVarInit(param);
		}
		WriteChar(')');
	}

	protected void WriteParameters!(CiMethod method, bool defaultArguments)
	{
		WriteChar('(');
		WriteRemainingParameters(method, true, defaultArguments);
	}

	protected void WriteBody!(CiMethod method)
	{
		if (method.CallType == CiCallType.Abstract)
			WriteCharLine(';');
		else {
			WriteNewLine();
			this.CurrentMethod = method;
			OpenBlock();
			FlattenBlock(method.Body);
			CloseBlock();
			this.CurrentMethod = null;
		}
	}

	protected void WritePublic!(CiContainerType container)
	{
		if (container.IsPublic)
			Write("public ");
	}

	protected void WriteEnumValue!(CiConst! konst)
	{
		WriteDoc(konst.Documentation);
		WriteName(konst);
		if (!(konst.Value is CiImplicitEnumValue)) {
			Write(" = ");
			konst.Value.Accept(this, CiPriority.Argument);
		}
	}

	public override void VisitEnumValue!(CiConst! konst, CiConst? previous)
	{
		if (previous != null)
			WriteCharLine(',');
		WriteEnumValue(konst);
	}

	protected abstract void WriteEnum!(CiEnum enu);

	protected void StartClass!(CiClass klass, string suffix, string extendsClause)
	{
		Write("class ");
		Write(klass.Name);
		Write(suffix);
		if (klass.HasBaseClass()) {
			Write(extendsClause);
			Write(klass.BaseClassName);
		}
	}

	protected void OpenClass!(CiClass klass, string suffix, string extendsClause)
	{
		StartClass(klass, suffix, extendsClause);
		WriteNewLine();
		OpenBlock();
	}

	protected abstract void WriteConst!(CiConst konst);

	protected abstract void WriteField!(CiField field);

	protected abstract void WriteMethod!(CiMethod method);

	protected void WriteMembers!(CiClass klass, bool constArrays)
	{
		for (CiSymbol? symbol = klass.First; symbol != null; symbol = symbol.Next) {
			switch (symbol) {
			case CiConst konst:
				WriteConst(konst);
				break;
			case CiField field:
				WriteField(field);
				break;
			case CiMethod method:
				WriteMethod(method);
				this.CurrentTemporaries.Clear();
				break;
			case CiVar _: // "this"
				break;
			default:
				assert false;
			}
		}
		if (constArrays) {
			foreach (CiConst konst in klass.ConstArrays)
				WriteConst(konst);
		}
	}

	protected bool WriteBaseClass!(CiClass klass, CiProgram program)
	{
		// topological sorting of class hierarchy
		if (this.WrittenClasses.Contains(klass))
			return false;
		this.WrittenClasses.Add(klass);
		if (klass.Parent is CiClass baseClass)
			WriteClass(baseClass, program);
		return true;
	}

	protected abstract void WriteClass!(CiClass klass, CiProgram program);

	protected void WriteTypes!(CiProgram program)
	{
		for (CiSymbol? type = program.First; type != null; type = type.Next) {
			switch (type) {
			case CiClass klass:
				WriteClass(klass, program);
				break;
			case CiEnum enu:
				WriteEnum(enu);
				break;
			default:
				assert false;
			}
		}
	}

	public abstract void WriteProgram!(CiProgram program);
}
